[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Jonny Comes",
    "section": "",
    "text": "Assistant Professor of Mathematics  The College of Idaho\n\nEducation\nUniversity of Oregon | Eugene, OR  PhD in Mathematics | 2010\nUniversity of Montana | Missoula, MT  M.A. in Mathematics | 2004  B.A. in Mathematics | 2003"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Hello!",
    "section": "",
    "text": "My name is Jonny. I’m an Assistant Professor of Mathematics at The College of Idaho.\nI obtained my Ph.D. in mathematics from the University of Oregon in 2010 under the supervision of Victor Ostrik. Prior to that I got my B.A. and M.A., both in mathematics, at the University of Montana. If you’d like to know more about my professional background, take a look at my cv.\nOn this site I keep lists of my publications, my students’ projects, and any resources I have written for student research projects. There is also a (mostly neglected) technical blog where I write about various math and cs stuff I’m thinking about.\nresearch student projects blog  Github  LinkedIn"
  },
  {
    "objectID": "posts/post-notebook/Untitled.html",
    "href": "posts/post-notebook/Untitled.html",
    "title": "Hello Title",
    "section": "",
    "text": "Hello\n\\(x+1=3\\) and \\[x+4=\\int x~dx\\]"
  },
  {
    "objectID": "posts/post-notebook/index.html",
    "href": "posts/post-notebook/index.html",
    "title": "matplotlib demo",
    "section": "",
    "text": "For a demonstration of a line plot on a polar axis, see Figure 1.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nr = np.arange(0, 2, 0.01)\ntheta = 2 * np.pi * r\nfig, ax = plt.subplots(\n  subplot_kw = {'projection': 'polar'} \n)\nax.plot(theta, r)\nax.set_rticks([0.5, 1, 1.5, 2])\nax.grid(True)\nplt.show()\n\n\n\n\n\nFigure 1: A line plot on a polar axis"
  },
  {
    "objectID": "posts/first-qiskit/First-qiskit.html",
    "href": "posts/first-qiskit/First-qiskit.html",
    "title": "Qiskit: getting started",
    "section": "",
    "text": "from qiskit import QuantumCircuit\n\nFirst, we create a 3-qubit quantum circuit:\n\nqc = QuantumCircuit(3)\n\nNow, let’s add some gates:\n\nqc.x(0)\nqc.h(2)\nqc.draw()\n\n     ┌───┐\nq_0: ┤ X ├\n     └───┘\nq_1: ─────\n     ┌───┐\nq_2: ┤ H ├\n     └───┘"
  },
  {
    "objectID": "posts/first-qiskit/index.html",
    "href": "posts/first-qiskit/index.html",
    "title": "Qiskit: getting started",
    "section": "",
    "text": "Qiskit is an open source software development kit (SDK) for working with quantum computation. There are several excellent tutorials for getting started with qiskit, as well as loads of great documentation you can find at qiskit.org. The following walks through some of the very basics including how to create quantum circuits, simulate measurments, and work with state vectors."
  },
  {
    "objectID": "posts/first-qiskit/index.html#creating-quantum-circuits",
    "href": "posts/first-qiskit/index.html#creating-quantum-circuits",
    "title": "Qiskit: getting started",
    "section": "Creating quantum circuits",
    "text": "Creating quantum circuits\n\nfrom qiskit import QuantumCircuit\n\nFirst, we create a 3-qubit quantum circuit:\n\nqc = QuantumCircuit(3)\n\nNext, we add some gates and draw the resulting circuit:\n\nqc.x(0)\nqc.h(2)\nqc.cx(0,2)\nqc.cx(1,2)\nqc.draw(output='mpl')"
  },
  {
    "objectID": "posts/first-qiskit/index.html#measuring",
    "href": "posts/first-qiskit/index.html#measuring",
    "title": "Qiskit: getting started",
    "section": "Measuring",
    "text": "Measuring\nWe can simulate a measurement, but first we need to import a simulator:\n\nfrom qiskit.providers.aer import QasmSimulator\n\nsimulator = QasmSimulator()\n\nNow, to measure we use a circuit having both a quantum and classical register:\n\ncircuit = QuantumCircuit(3, 3)\n\nNow, let’s add some gates including some measuments:\n\ncircuit.h(0)\ncircuit.cx(0, 1)\ncircuit.cx(0, 2)\ncircuit.measure([0,1,2], [0,1,2])\ncircuit.draw()\n\n     ┌───┐             ┌─┐   \nq_0: ┤ H ├──■────■─────┤M├───\n     └───┘┌─┴─┐  │  ┌─┐└╥┘   \nq_1: ─────┤ X ├──┼──┤M├─╫────\n          └───┘┌─┴─┐└╥┘ ║ ┌─┐\nq_2: ──────────┤ X ├─╫──╫─┤M├\n               └───┘ ║  ║ └╥┘\nc: 3/════════════════╩══╩══╩═\n                     1  0  2 \n\n\nNext, we simulate and count the results:\n\njob = simulator.run(circuit, shots=1000)\nresult = job.result()\ncounts = result.get_counts(circuit)\nprint(counts)\n\n{'000': 506, '111': 494}\n\n\nWe can plot the results using qiskits built in visualization:\n\nfrom qiskit.visualization import plot_histogram\n\nplot_histogram(counts)"
  },
  {
    "objectID": "posts/first-qiskit/index.html#measurements",
    "href": "posts/first-qiskit/index.html#measurements",
    "title": "Qiskit: getting started",
    "section": "Measurements",
    "text": "Measurements\nWe can simulate a measurement, but first we need to import a simulator:\n\nfrom qiskit.providers.aer import QasmSimulator\n\nsimulator = QasmSimulator()\n\n\nMeasure using a classical register explicitly\nOne way to measure is to use a circuit having both a quantum and classical register:\n\ncircuit = QuantumCircuit(3, 3)\n\nNow, let’s add some gates including some measuments:\n\ncircuit.h(0)\ncircuit.cx(0, 1)\ncircuit.cx(0, 2)\ncircuit.measure([0,1,2], [0,1,2])\ncircuit.draw(output='mpl')\n\n\n\n\nNext, we simulate and count the results:\n\njob = simulator.run(circuit, shots=1000)\nresult = job.result()\ncounts = result.get_counts(circuit)\nprint(counts)\n\n{'000': 469, '111': 531}\n\n\nWe can plot the results using qiskits built in visualization:\n\nfrom qiskit.visualization import plot_histogram\n\nplot_histogram(counts)\n\n\n\n\n\n\nUsing the measure_all() method\nAlternatively, if we want to measure all the qubits we can use the measure_all() method:\n\ncircuit = QuantumCircuit(3)\n\nNow, let’s add some gates including some measuments:\n\ncircuit.h(0)\ncircuit.cx(0, 1)\ncircuit.cx(0, 2)\ncircuit.measure_all()\ncircuit.draw(output='mpl')\n\n\n\n\nWe should see similar results:\n\njob = simulator.run(circuit, shots=1000)\nresult = job.result()\ncounts = result.get_counts(circuit)\nprint(counts)\n\n{'000': 490, '111': 510}\n\n\nOf course, this will only work if we want to measure all the qubits in the output state of the circuit."
  },
  {
    "objectID": "posts/first-qiskit/index.html#circuit-orientation",
    "href": "posts/first-qiskit/index.html#circuit-orientation",
    "title": "Qiskit: getting started",
    "section": "Circuit orientation",
    "text": "Circuit orientation\nQiskit orients circuits so that the qubits \\(q_0, q_1,\\ldots, q_{n-1}\\) labelling the circut from top to bottom correspond to the input state \\(|q_{n-1}\\cdots q_1q_0\\rangle\\). To see this, let’s create a simple gate that maps \\(|000\\rangle\\mapsto|100\\rangle\\).\n\ncirc = QuantumCircuit(3)\ncirc.x(2)\ncirc.measure_all()\ncirc.draw(output='mpl')\n\n\n\n\nTo see that the circuit above does the trick, let’s measure:\n\njob = simulator.run(circ, shots=1000)\nresult = job.result()\ncounts = result.get_counts(circ)\nprint(counts)\n\n{'100': 1000}\n\n\nI prefer the flipped orientation where the top qubit in the circuit corresponds to the left qubit in the tensor product. To have qiskit draw circuits with my prefered orientation, we simply pass reverse_bits=True to the draw() method:\n\ncirc.draw(output='mpl', reverse_bits=True)\n\n\n\n\n\njob = simulator.run(circ, shots=1000)\nresult = job.result()\ncounts = result.get_counts(circ)\nprint(counts)\n\n{'100': 1000}"
  },
  {
    "objectID": "posts/first-qiskit/index.html#state-vectors",
    "href": "posts/first-qiskit/index.html#state-vectors",
    "title": "Qiskit: getting started",
    "section": "State vectors",
    "text": "State vectors\nWe can use qiskits Statevector object work with \\(n\\)-qubit states.\n\nfrom qiskit.quantum_info import Statevector\n\nFor example, the following creates the state \\(|7\\rangle\\) for a 4-qubit register:\n\nstate = Statevector.from_int(7, 2**4)\nstate.draw('latex')\n\n\\[ |0111\\rangle\\]\n\n\nWe can run this state through a quantum circuit as in the following example:\n\nqc = QuantumCircuit(4)\nqc.h(1)\nqc.cx(0, 2)\nqc.swap(1,3)\nqc.draw(reverse_bits=True)\n\n                  \nq_3: ───────────X─\n          ┌───┐ │ \nq_2: ─────┤ X ├─┼─\n     ┌───┐└─┬─┘ │ \nq_1: ┤ H ├──┼───X─\n     └───┘  │     \nq_0: ───────■─────\n                  \n\n\n\nstate = state.evolve(qc)\nstate.draw('latex')\n\n\\[\\frac{\\sqrt{2}}{2} |0001\\rangle- \\frac{\\sqrt{2}}{2} |1001\\rangle\\]"
  },
  {
    "objectID": "posts/first-qiskit/index.html#state-vectors-of-integers",
    "href": "posts/first-qiskit/index.html#state-vectors-of-integers",
    "title": "Qiskit: getting started",
    "section": "State vectors of integers",
    "text": "State vectors of integers\nWe can use qiskits Statevector object work with \\(n\\)-qubit states.\n\nfrom qiskit.quantum_info import Statevector\n\nFor example, the following creates the state \\(|7\\rangle\\) for a 4-qubit register:\n\nstate = Statevector.from_int(7, 2**4)\nstate.draw('latex')\n\n\\[ |0111\\rangle\\]\n\n\nWe can visualize the state \\(|7\\rangle\\) on a register of Bloch spheres as follows:\n\nfrom qiskit.visualization import plot_bloch_multivector\n\nplot_bloch_multivector(state)\n\n\n\n\nWe can run this state through a quantum circuit as in the following example:\n\nqc = QuantumCircuit(4)\nqc.h(1)\nqc.h(2)\nqc.cx(0, 2)\nqc.swap(1,3)\nqc.draw(reverse_bits=True)\n\n                  \nq_3: ───────────X─\n     ┌───┐┌───┐ │ \nq_2: ┤ H ├┤ X ├─┼─\n     ├───┤└─┬─┘ │ \nq_1: ┤ H ├──┼───X─\n     └───┘  │     \nq_0: ───────■─────\n                  \n\n\n\nstate = state.evolve(qc)\nstate.draw('latex')\n\n\\[- \\frac{1}{2} |0001\\rangle+\\frac{1}{2} |0101\\rangle+\\frac{1}{2} |1001\\rangle- \\frac{1}{2} |1101\\rangle\\]\n\n\nFinally, let’s look at this state using Bloch spheres:\n\nplot_bloch_multivector(state)"
  },
  {
    "objectID": "posts/first-qiskit/index.html#the-bloch-sphere",
    "href": "posts/first-qiskit/index.html#the-bloch-sphere",
    "title": "Qiskit: getting started",
    "section": "The Bloch sphere",
    "text": "The Bloch sphere\n\nfrom qiskit.visualization import plot_bloch_vector\n\n\nplot_bloch_vector([1,0,0])"
  },
  {
    "objectID": "posts/first-qiskit/index.html#state-vectors-and-bloch-spheres",
    "href": "posts/first-qiskit/index.html#state-vectors-and-bloch-spheres",
    "title": "Qiskit: getting started",
    "section": "State vectors and Bloch spheres",
    "text": "State vectors and Bloch spheres\nWe can use qiskits Statevector object work with \\(n\\)-qubit states.\n\nfrom qiskit.quantum_info import Statevector\n\nFor example, the following creates the state \\(|7\\rangle\\) for a 4-qubit register:\n\nstate = Statevector.from_int(7, 2**4)\nstate.draw('latex')\n\n\\[ |0111\\rangle\\]\n\n\nWe can visualize the state \\(|7\\rangle\\) on a register of Bloch spheres as follows:\n\nfrom qiskit.visualization import plot_bloch_multivector\n\nplot_bloch_multivector(state, reverse_bits=True)\n\n\n\n\nWe can run this state through a quantum circuit as in the following example:\n\nqc = QuantumCircuit(4)\nqc.h(1)\nqc.h(2)\nqc.cx(0, 2)\nqc.swap(1,3)\nqc.draw(output='mpl', reverse_bits=True)\n\n\n\n\n\nstate = state.evolve(qc)\nstate.draw('latex')\n\n\\[- \\frac{1}{2} |0001\\rangle+\\frac{1}{2} |0101\\rangle+\\frac{1}{2} |1001\\rangle- \\frac{1}{2} |1101\\rangle\\]\n\n\nFinally, let’s look at this state using Bloch spheres:\n\nplot_bloch_multivector(state, reverse_bits=True)"
  },
  {
    "objectID": "posts/quantum-fourier-transform/index.html",
    "href": "posts/quantum-fourier-transform/index.html",
    "title": "Quantum Fourier transform",
    "section": "",
    "text": "The Fourier transform is a beautiful function with many important applications. There is a wonderful introduction to the Fourier transform by 3 Blue 1 Brown that is well worth watching. The following is a description of the quantum Fourier transform (QFT). After defining a closed formula for QFT, I will explain how to build the QFT circuit using a recursive formula. In the end, I will prove that the closed formula and recursive formula agree. All the quantum circuits in this post are created with qiskit.\n\n\nCode\nfrom qiskit import QuantumCircuit\nfrom math import pi\n\n\n\n\nFix a positive integer \\(n\\) and let \\(N=2^n\\) denote the dimension of the \\(n\\)-qubit state space. In what follows, given an integer \\(0\\leq a< N\\) we write \\(|a\\rangle\\) for the state vector corresponding to the \\(a\\)-th standard basis vector. In other words, \\(|a\\rangle=|a_{n-1}\\cdots a_1a_0\\rangle\\) where each \\(a_i\\in\\{0,1\\}\\) and \\(a=\\sum\\limits_{k=0}^{n-1}a_k2^k\\). For example, when \\(n=3\\) we have\n\\[\\begin{align*}\n    |0\\rangle &= |000\\rangle, &\n    |1\\rangle &= |001\\rangle, \\\\\n    |2\\rangle &= |010\\rangle, &\n    |3\\rangle &= |011\\rangle, \\\\\n    |4\\rangle &= |100\\rangle, &\n    |5\\rangle &= |101\\rangle, \\\\\n    |6\\rangle &= |110\\rangle, &\n    |7\\rangle &= |111\\rangle. \\\\\n\\end{align*}\\]\nThis is just the usual binary representation of integers, but with qubits. I like to refer to \\(|a\\rangle\\) as the (standard) \\(n\\)-qubit representation of the integer \\(a\\).\n\n\n\nThe quantum Fourier transform \\(QFT_n\\) is define on the \\(n\\)-qubit representation of \\(a\\) by \\[\nQFT_n|a\\rangle = \\dfrac{1}{\\sqrt{N}}\\sum_{b=0}^{N-1}e^{2\\pi i a b/N}|b\\rangle.\n\\tag{1}\\]\n\n\nWhen \\(n=1\\) (so that \\(N=2\\)) the closed formula above shows that \\(QFT_1\\) maps\n\\[\\begin{align*}\n    |0\\rangle & \\mapsto \\dfrac{1}{\\sqrt{2}}\\left(|0\\rangle + |1\\rangle\\right)\\\\\n    |1\\rangle & \\mapsto \\dfrac{1}{\\sqrt{2}}\\left(|0\\rangle - |1\\rangle\\right)\n\\end{align*}\\]\nThis is the same mapping given by our beloved Hadamard gate, so \\(QFT_1=H\\).\n\n\n\nWhen \\(n=2\\) (so that \\(N=4\\)) the closed formula shows that \\(QFT_2\\) maps\n\\[\\begin{align*}\n    |0\\rangle & \\mapsto \\dfrac{1}{2}\\left(|0\\rangle + |1\\rangle + |2\\rangle + |3\\rangle\\right)\\\\\n    |1\\rangle & \\mapsto \\dfrac{1}{2}\\left(|0\\rangle + i|1\\rangle -|2\\rangle - i|3\\rangle\\right)\\\\\n    |2\\rangle & \\mapsto \\dfrac{1}{2}\\left(|0\\rangle - |1\\rangle + |2\\rangle - |3\\rangle\\right)\\\\\n    |3\\rangle & \\mapsto \\dfrac{1}{2}\\left(|0\\rangle - i|1\\rangle - |2\\rangle + i|3\\rangle\\right)\n\\end{align*} \\tag{2}\\]\nEquivalently, expanding the above states into qubits we see \\(QFT_2\\) maps\n\\[\\begin{align*}\n    |00\\rangle & \\mapsto \\dfrac{1}{2}\\left(|00\\rangle + |01\\rangle + |10\\rangle + |11\\rangle\\right)\\\\\n    |01\\rangle & \\mapsto \\dfrac{1}{2}\\left(|00\\rangle + i|01\\rangle -|10\\rangle - i|11\\rangle\\right)\\\\\n    |10\\rangle & \\mapsto \\dfrac{1}{2}\\left(|00\\rangle - |01\\rangle + |10\\rangle - |11\\rangle\\right)\\\\\n    |11\\rangle & \\mapsto \\dfrac{1}{2}\\left(|00\\rangle - i|01\\rangle - |10\\rangle + i|11\\rangle\\right)\n\\end{align*} \\tag{3}\\]"
  },
  {
    "objectID": "posts/quantum-fourier-transform/index.html#the-qft-circuit",
    "href": "posts/quantum-fourier-transform/index.html#the-qft-circuit",
    "title": "Quantum Fourier transform",
    "section": "The QFT circuit",
    "text": "The QFT circuit\n\nCP-chains\nOne of the building blocks (subcircuits) of the QFT circuit consists of a composition of controlled phase gates. We will call these subcircuits CP-chains. In the following we will describe these CP-chains and give an explicit formula for how they map qubit states.\n\nPhase gates\nWe will write \\(P_\\phi\\) for the P-gate, which depends on a parameter \\(\\phi\\), that maps qubits as follows\n\\[\\begin{align*}\n    |0\\rangle & \\mapsto |0\\rangle\\\\\n    |1\\rangle & \\mapsto e^{\\phi i} |1\\rangle\n\\end{align*}\\] In other words, a P-gate applies a relative phase change to the \\(|1\\rangle\\) component of a qubit. If you prefer to describe gates by matrices, then \\[P_\\phi=\\begin{pmatrix}\n    1 & 0\\\\\n    0 & e^{\\phi i}\n\\end{pmatrix}\\]\nNote that we can get a little clever and write the P-gate mapping as \\[P_\\phi: |q\\rangle \\mapsto e^{q\\phi i}|q\\rangle\\] where \\(q\\in\\{0, 1\\}\\). The P-gate \\(P_{\\pi/2}\\) is pictured as follows:\n\n\nCode\nqc = QuantumCircuit(1)\nqc.p(pi/2, 0)\nqc.draw(output='mpl')\n\n\n\n\n\n\n\nControlled phase gates\nUsing the cleverness above, a controlled P-gate will map \\[CP_\\phi: |q_1q_0\\rangle \\mapsto e^{q_1q_0\\phi i}|q_1q_0\\rangle.\\]\nThe controlled P-gate \\(CP_{\\pi/2}\\) is drawn as follows:\n\n\nCode\nqc = QuantumCircuit(2)\nqc.cp(pi/2, 0, 1)\nqc.draw(output='mpl', reverse_bits=True)\n\n\n\n\n\n\n\nA chain of controlled phase gates\nSuppose we are concerned with a \\((n+1)\\)-qubit state space. Consider \\(n\\) CP-gates: \\(CP_{\\pi/2^k}\\) between the \\(n\\)-th and \\((n-k)\\)-th qubit for each \\(1\\leq k\\leq n\\). For example, when \\(n=4\\) the composition of these four CP-gates is the following:\n\n\nCode\ndef cpc(n):\n    qc = QuantumCircuit(n, name='   CPC   ')\n    for k in range(1, n):\n        qc.cp(pi/(2**k), n-1, n-1-k)\n    return qc\n\ncpc(5).draw(output='mpl', reverse_bits=True)\n\n\n\n\n\nI don’t know a standard name for the circuit above, so I’ll refer to the composition of these \\(n\\) CP-gates as the CP-chain, denoted \\(CPC_{n+1}\\). For example, the circuit drawn above is \\(CPC_5\\). Based on the mapping of \\(CP_\\phi\\) given above, it follows that the CP-chain maps \\(|a\\rangle=|a_n\\cdots a_1a_0\\rangle\\), the \\((n+1)\\)-qubit representation of an integer \\(0\\leq a< 2^{n+1}\\), as follows: \\[CPC_{n+1}:|a_na_{n-1}\\cdots a_1a_0\\rangle \\mapsto \\prod\\limits_{k=1}^ne^{\\frac{\\pi i\na_na_{n-k}}{2^k}}|a_na_{n-1}\\cdots a_1a_0\\rangle\\] To simplify the expression above, it will be useful to let \\(a'\\) denote the integer with \\(n\\)-qubit representation \\(|a'\\rangle=|a_{n-1}\\cdots a_1a_0\\rangle\\) so that \\(|a\\rangle=|a_n\\rangle\\otimes|a'\\rangle\\). With this notation, the amplitude above simplifies as \\[\\begin{align*}\n    \\prod\\limits_{k=1}^ne^{\\frac{\\pi i a_na_{n-k}}{2^k}}\n    & =e^{\\sum_{k=1}^n\\frac{\\pi i a_na_{n-k}}{2^k}} \\\\\n    & =e^{\\frac{\\pi i a_n}{2^n}\\sum_{k=1}^na_{n-k}2^{n-k}} \\\\\n    & =e^{\\frac{\\pi i a_n}{2^n}\\sum_{k=0}^{n-1}a_{k}2^{k}} \\\\\n    & =e^{\\frac{\\pi i a_na'}{2^n}}. \\\\\n\\end{align*}\\] Thus, the CP-chain mapping can be written as \\[\nCPC_{n+1}:|a_n\\rangle\\otimes|a'\\rangle \\mapsto e^{\\frac{\\pi i a_na'}{2^n}} |a_n\\rangle\\otimes|a'\\rangle.\n\\tag{4}\\]\n\n\n\nReverse circuits\nReversing the order of the qubits is another component of the QFT circuit. Reversing qubits can easily be accomplished using swap gates. The swap gate, pictured below, maps \\(|q_1q_0\\rangle\\to|q_0q_1\\rangle\\).\n\n\nCode\nqc = QuantumCircuit(2)\nqc.swap(0, 1)\nqc.draw(output='mpl', reverse_bits=True)\n\n\n\n\n\nWe let \\(Rev_n\\) for the \\(n\\)-qubit gate that reverses the qubit order. For example, \\(Rev_2\\) is the swap gate above. To obtain \\(Rev_n\\), one simply swaps the first and last qubit, the second and second to last qubit, and so on. For example, the following is \\(Rev_7\\):\n\n\nCode\ndef rev(n):\n    qc = QuantumCircuit(n, name='   Rev   ')\n    for i in range(n//2):\n        qc.swap(i, n-i-1)\n    return qc\n\nrev(7).draw(output='mpl', reverse_bits=True)\n\n\n\n\n\n\n\nA recursive formula for QFT\nWe are now in position to state recursive formula for the QFT that will allow use to build the QFT circuits:\n\\[\nQFT_{n+1} = Rev_{n+1}\\circ (I\\otimes (Rev_n\\circ QFT_n))\\circ CPC_{n+1}\\circ(H\\otimes I^{\\otimes n})\n\\tag{5}\\]\nThe formula above may be easier to visualize using circuits. Here is the recursively defined QFT circuit:\n\n\nCode\ndef qft(n):\n    qc = QuantumCircuit(n, name=f'  QFT  ')\n    qc.h(n-1)\n    if n == 1:\n        return qc\n    qc.append(cpc(n), range(n))\n    qc.append(qft(n-1), range(n-1))\n    qc.append(rev(n-1), range(n-1))\n    qc.append(rev(n), range(n))\n\n    return qc\n\nqft(5).draw(output='mpl', reverse_bits=True, style={\n    \"displaycolor\": {\n        \"   Rev   \": [ # gate name\n            \"#555555\", # box color (grey)\n            \"#FFFFFF\" # box text color (white)\n        ],\n        \"  QFT  \": [ # gate name\n            \"#da1e28\", # box color (red)\n            \"#FFFFFF\" # box text color (white)\n        ],\n    }})\n\n\n\n\n\n\n\nThe QFT circuit\nStarting with \\(QFT_1=H\\), the recursive formula 5 can be used to build all the QFT circuits in terms of H, CP, and swap gates. For example, here is \\(QFT_2\\):\n\n\nCode\nqc = QuantumCircuit(2)\nqc.h(1)\nqc.cp(pi/2, 1, 0)\nqc.h(0)\nqc.swap(0,1)\nqc.draw(output='mpl', reverse_bits=True)\n\n\n\n\n\nPlugging this into the recursive formula 5 gives us \\(QFT_3\\). After simplifying (Rev-gates are their own inverses) and expanding the CPC and Rev gates into CP and swap gates, we get the following for \\(QFT_3\\):\n\n\nCode\nqc = QuantumCircuit(3)\nqc.h(2)\nqc.cp(pi/2, 2, 1)\nqc.cp(pi/4, 2, 0)\nqc.h(1)\nqc.cp(pi/2, 1, 0)\nqc.h(0)\nqc.swap(0,2)\nqc.draw(output='mpl', reverse_bits=True)\n\n\n\n\n\nSimilarly, we can plug the QFT-circuit above into the recursive formula 5 and (after expanding and simplifying) get \\(QFT_4\\) in terms of H, CP, and swap gates:\n\n\nCode\nqc = QuantumCircuit(4)\nqc.h(3)\nqc.cp(pi/2, 3, 2)\nqc.cp(pi/4, 3, 1)\nqc.cp(pi/8, 3, 0)\nqc.h(2)\nqc.cp(pi/2, 2, 1)\nqc.cp(pi/4, 2, 0)\nqc.h(1)\nqc.cp(pi/2, 1, 0)\nqc.h(0)\nqc.swap(0,3)\nqc.swap(1,2)\nqc.draw(output='mpl', reverse_bits=True)\n\n\n\n\n\n\n\nA couple QFT computations with qiskit\nIn the code blocks above, the recursive formula 5 was used to create the QFT-circuit with qiskit. The following shows how to perform QFT calculations with qiskit. First, lets check that our circuit correctly computes \\(QFT_2|3\\rangle\\) (compare with 2 and 3).\n\nfrom qiskit.quantum_info import Statevector\nn = 2\na = 3\nstate_in = Statevector.from_int(a, 2**n)\nstate_out = state_in.evolve(qft(n))\nstate_out.draw('latex')\n\n\\[\\frac{1}{2} |00\\rangle- \\frac{i}{2} |01\\rangle- \\frac{1}{2} |10\\rangle+\\frac{i}{2} |11\\rangle\\]\n\n\nFor a slightly larger computation, let’s compute \\(QFT_3|7\\rangle\\):\n\nn = 3\na = 7\nstate_in = Statevector.from_int(a, 2**n)\nstate_out = state_in.evolve(qft(n))\nstate_out.draw('latex')\n\n\\[\\frac{\\sqrt{2}}{4} |000\\rangle+ (\\frac{1}{4} - \\frac{i}{4}) |001\\rangle- \\frac{\\sqrt{2} i}{4} |010\\rangle+ (- \\frac{1}{4} - \\frac{i}{4}) |011\\rangle- \\frac{\\sqrt{2}}{4} |100\\rangle+ (- \\frac{1}{4} + \\frac{i}{4}) |101\\rangle+\\frac{\\sqrt{2} i}{4} |110\\rangle+ (\\frac{1}{4} + \\frac{i}{4}) |111\\rangle\\]"
  },
  {
    "objectID": "posts/quantum-fourier-transform/index.html#proof-that-qft-satisfies-the-recursive-formula",
    "href": "posts/quantum-fourier-transform/index.html#proof-that-qft-satisfies-the-recursive-formula",
    "title": "Quantum Fourier transform",
    "section": "Proof that QFT satisfies the recursive formula",
    "text": "Proof that QFT satisfies the recursive formula\nTo prove the recursive formula 5 we compute the output of the recursive circuit on an arbitrary \\((n+1)\\)-qubit representation of an integer: \\(|a\\rangle=|a_na_{n-1}\\cdots a_0\\rangle\\). In doing so, it will continue to use the notation from Section 2.1.3 by writing \\[\n|a\\rangle=|a_n\\rangle\\otimes|a'\\rangle.\n\\tag{6}\\] Following 5, we first apply the Hadamard gate (which is \\(QFT_1\\)) to the left (top) qubit: \\[\n|a_n\\rangle\\otimes|a'\\rangle \\mapsto \\dfrac{1}{\\sqrt{2}}\\sum_{0\\leq b_0\\leq 1}e^{\\pi i a_n b_0}|b_0\\rangle\\otimes|a'\\rangle.\n\\] Next, (according to 5) we apply the CPC-gate to the result and use 4 to get \\[\n\\dfrac{1}{\\sqrt{2}}\\sum_{0\\leq b_0\\leq 1}e^{\\pi i b_0 a_n}|b_0\\rangle\\otimes|a'\\rangle\\mapsto \\dfrac{1}{\\sqrt{2}}\\sum_{0\\leq b_0\\leq 1}e^{\\pi i b_0 a_n}e^{\\frac{\\pi i b_0 a'}{2^n}}|b_0\\rangle\\otimes|a'\\rangle.\n\\tag{7}\\] Since \\[\n2^na_n + a'=a\n\\tag{8}\\] (which follows from 6), the exponentials in the output of 7 can be simplified as follows: \\[\ne^{\\pi i b_0 a_n}e^{\\frac{\\pi i b_0 a'}{2^n}}=e^{\\frac{\\pi i b_0(2^na_n+a')}{2^n}}=e^{\\frac{\\pi i b_0 a}{2^n}}\n\\] Thus, the output of 7 can be written as \\[\n\\dfrac{1}{\\sqrt{2}}\\sum_{0\\leq b_0\\leq 1}e^{\\frac{\\pi i b_0 a}{2^n}}|b_0\\rangle\\otimes|a'\\rangle.\n\\] Next, (according to 5) we apply the QFT-gate to the right (bottom) \\(n\\) qubits using 1: \\[\n\\dfrac{1}{\\sqrt{2}}\\sum_{0\\leq b_0\\leq 1}e^{\\frac{\\pi i b_0 a}{2^n}}|b_0\\rangle\\otimes|a'\\rangle\n\\mapsto\n\\dfrac{1}{\\sqrt{2}}\\sum_{0\\leq b_0\\leq 1}e^{\\frac{\\pi i b_0 a}{2^n}}|b_0\\rangle\\otimes\\dfrac{1}{\\sqrt{2^n}}\\sum_{0\\leq b'<2^n}e^{\\frac{2\\pi i a'b'}{2^n}}|b'\\rangle.\n\\] If we write \\(|b'\\rangle=|b_nb_{n-1}\\cdots b_1\\rangle\\), then the output above can be written as \\[\n\\dfrac{1}{\\sqrt{2^{n+1}}}\\sum_{0\\leq b_0,b_1,\\ldots,b_n\\leq 1}e^{\\frac{\\pi i b_0 a}{2^n}}e^{\\frac{2\\pi i a'b'}{2^n}}|b_0\\rangle\\otimes|b_n\\cdots b_1\\rangle.\n\\] Now, (still following 5) we reverse the last (bottom) \\(n\\) qubits to get\n\\[\\begin{align*}\n& \\dfrac{1}{\\sqrt{2^{n+1}}}\\sum_{0\\leq b_0,b_1,\\ldots,b_n\\leq 1}e^{\\frac{\\pi i b_0 a}{2^n}}e^{\\frac{2\\pi i a'b'}{2^n}}|b_0\\rangle\\otimes|b_1\\cdots b_n\\rangle \\\\\n& =\\dfrac{1}{\\sqrt{2^{n+1}}}\\sum_{0\\leq b_0,b_1,\\ldots,b_n\\leq 1}e^{\\frac{\\pi i b_0 a}{2^n}}e^{\\frac{2\\pi i a'b'}{2^n}}|b_0b_1\\cdots b_n\\rangle. \\\\\n& =\\dfrac{1}{\\sqrt{2^{n+1}}}\\sum_{0\\leq b_0,b_1,\\ldots,b_n\\leq 1}e^{\\frac{\\pi i (ab_0+2a'b')}{2^n}}|b_0b_1\\cdots b_n\\rangle.\n\\end{align*} \\tag{9}\\]\nFinally, if we let \\(b\\) denote the integer with \\(|b\\rangle=|b_n\\cdots b_0\\rangle\\), then after we reverse all \\(n+1\\) qubits (the last step in 5) in 9 we get \\[\n\\dfrac{1}{\\sqrt{2^{n+1}}}\\sum_{0\\leq b_0,\\ldots,b_n\\leq 1}e^{\\frac{\\pi i (ab_0+2a'b')}{2^n}}|b_n\\cdots b_0\\rangle\n=\n\\dfrac{1}{\\sqrt{2^{n+1}}}\\sum_{b=0}^{2^{n+1}-1}e^{\\frac{\\pi i (ab_0+2a'b')}{2^n}}|b\\rangle.\n\\] The state above the output of the recursive gate 5 applied to \\(|a\\rangle\\). On the other hand, using 1 we get \\[\nQFT_{n+1}|a\\rangle = \\dfrac{1}{\\sqrt{2^{n+1}}}\\sum_{b=0}^{2^{n+1}-1}e^{\\frac{2\\pi i ab}{2^{n+1}}}|b\\rangle.\n\\] Thus, to complete the proof it suffices to show \\[\ne^{\\frac{\\pi i (ab_0+2a'b')}{2^n}} = e^{\\frac{2\\pi i ab}{2^{n+1}}}\n\\] or equivalently \\[\ne^{\\frac{\\pi i (ab-ab_0-2a'b')}{2^{n}}} = 1.\n\\]\nSince \\(|b\\rangle=|b_n\\cdots b_1b_0\\rangle\\) and \\(|b'\\rangle=|b_n\\cdots b_1\\rangle\\), it follows that \\(b=2b'+b_0\\) so that \\(b-b_0=2b'\\). Using this fact along with \\(a-a'=2^na_n\\) (which follows from 8) we get the desired result: \\[\\begin{align*}\ne^{\\frac{\\pi i (ab-ab_0-2a'b')}{2^{n}}}\n& = e^{\\frac{\\pi i (2ab'-2a'b')}{2^{n}}} \\\\\n& = e^{\\frac{\\pi i (2(a-a')b')}{2^{n}}} \\\\\n& = e^{\\frac{\\pi i (2^{n+1}a_nb')}{2^{n}}}\\\\\n& = e^{2\\pi i a_nb'}\\\\\n& = 1.\n\\end{align*}\\]"
  },
  {
    "objectID": "posts/phase-estimation/index.html",
    "href": "posts/phase-estimation/index.html",
    "title": "Quantum Phase Estimation",
    "section": "",
    "text": "The story of quantum phase estimation starts with a unitary matrix \\(U\\). Suppose \\(|x\\rangle\\) is an eigenvector of \\(U\\) so that \\(U|x\\rangle=\\lambda|x\\rangle\\) for some complex number \\(\\lambda\\). Since \\(U\\) is unitary, hence distance preserving, we know \\(|\\lambda|=1\\) so that \\(\\lambda=e^{2\\pi i\\theta}\\) for some \\(0\\leq\\theta<1\\). Quantum phase estimation uses a quantum circuit, depending on \\(U\\), to estimate \\(\\theta\\).\nThe quantum circuit for quantum phase estimation depends on the quantum Fourier transform (QFT). In a previous post I discussed QFT. In particular, I constructed a quantum circuit for QFT using qiskit. In this post I will reuse that code.\n\n\nCode\nfrom qiskit import QuantumCircuit\nfrom qiskit.circuit.library.standard_gates import *\nfrom qiskit.quantum_info import Statevector\nfrom math import pi\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\ndef cpc(n):\n    '''\n    Returns an n-qubit quantum circuit consisting of a chain \n    of CP-gates to use in the construction of the QFT circuit.\n    '''\n    qc = QuantumCircuit(n, name='   CPC')\n    for k in range(1, n):\n        qc.cp(pi/(2**k), n-1, n-1-k)\n    return qc\n\ndef rev(n):\n    '''\n    Returns an n-qubit quantum circuit that reverses \n    the order of the n qubits.\n    '''\n    qc = QuantumCircuit(n, name='   Rev')\n    for i in range(n//2):\n        qc.swap(i, n-i-1)\n    return qc\n\ndef qft(n):\n    '''\n    Returns the n-qubit QFT circuit.\n    '''\n    qc = QuantumCircuit(n, name=f'  QFT')\n    qc.h(n-1)\n    if n == 1:\n        return qc\n\n    qc.append(cpc(n), range(n))\n    qc.append(qft(n-1), range(n-1))\n    qc.append(rev(n-1), range(n-1))\n    qc.append(rev(n), range(n))\n    return qc\n\n\nI first read about quantum phase estimation in qiskit’s book while trying to better understand Shor’s algorithm. Much of what I’ve written below is merely a retelling of qiskit’s treatment. I plan to post about Shor’s algorithm soon.\n\n\nFix a unitary matrix \\(U\\). The controlled \\(U\\)-gate is defined by \\[\n\\begin{align*}\nCU: & |0\\rangle\\otimes|v\\rangle \\mapsto |0\\rangle\\otimes|v\\rangle\\\\\n    & |1\\rangle\\otimes|v\\rangle \\mapsto |1\\rangle\\otimes U|v\\rangle.\n\\end{align*}\n\\] In particular, if \\(|x\\rangle\\) is an eigenvector for \\(U\\) with eigenvalue \\(e^{2\\pi i\\theta}\\) then \\[\n\\begin{align*}\nCU: & |0\\rangle\\otimes|x\\rangle \\mapsto |0\\rangle\\otimes|x\\rangle\\\\\n    & |1\\rangle\\otimes|x\\rangle \\mapsto e^{2\\pi i\\theta}|1\\rangle\\otimes|x\\rangle\n\\end{align*}\n\\] or more compactly, for each \\(q\\in\\{0,1\\}\\) \\[\nCU:|q\\rangle\\otimes|x\\rangle \\mapsto e^{2\\pi i\\theta q}|q\\rangle\\otimes|x\\rangle.\n\\]\nMore generally, we will write \\(CU_k\\) for the controlled \\(U\\)-gate mapping \\[\nCU_k:|q_{n-1}\\cdots q_0\\rangle\\otimes|v\\rangle \\mapsto\n\\begin{cases}\n    |q_{n-1}\\cdots q_0\\rangle\\otimes |v\\rangle & \\text{if }q_k=0\\\\\n    |q_{n-1}\\cdots q_0\\rangle\\otimes U|v\\rangle & \\text{if }q_k=1\n\\end{cases}\n\\] In particular, substituting the eigenvector \\(|x\\rangle\\) we get \\[\nCU_k:|q_{n-1}\\cdots q_0\\rangle\\otimes|x\\rangle \\mapsto e^{2\\pi i\\theta q_k} |q_{n-1}\\cdots q_0\\rangle\\otimes|x\\rangle.\n\\tag{1}\\]\n\n\n\nWe can build a controlled \\(U\\)-gate in qiskit by applying the control() method to a gate object. For example, the following creates a CU-gate when \\(U=H\\), the Hadamard gate, and places it in a 4-qubit circuit.\n\nu = HGate()\ncu = u.control()\nqc = QuantumCircuit(4)\nqc.append(cu, [2,0])\nqc.draw(output='mpl', reverse_bits=True)\n\n\n\n\n\n\n\nThe phase estimation circuit is given by the following composition: \\[\n(QFT^\\dagger_n\\otimes I)(CU_{n-1}^{2^{n-1}}\\cdots CU_2^4CU_1^2CU_0)(H^{\\otimes n}\\otimes I),\n\\tag{2}\\] where \\(QFT^\\dagger_n\\) is the inverse quantum Fourier transform. Using the qiskit implementation of QFT from this post, we can implement the circuit for quantum phase estimation. For example, here is the phase estimation circuit using the \\(Y\\)-gate for \\(U\\), and \\(n=3\\):\n\n\nCode\ndef phase_est(u, n):\n    '''\n    Returns the quantum circuit for phase estimation depending\n    on the gate u, extended with n-qubits. \n    If measure flag is True, will return with first (top)\n    measurement of first (top) n qubits.\n    '''\n    m = u.num_qubits\n    qc = QuantumCircuit(n+m)\n    \n    for i in range(n):\n        qc.h(m+i)\n    cu = u.control()\n    for i in range(n):\n        for _ in range(2**i):\n            qc.append(cu, [m+i] + list(range(m)))\n    qc.append(qft(n).inverse(), range(m, m+n))\n\n    return qc\n\n\nphase_est(YGate(), 3).draw(output='mpl', reverse_bits=True, style={\n    \"displaycolor\": {\n        \"  QFT_dg\": [ # gate name\n            \"#da1e28\", # box color (red)\n            \"#FFFFFF\" # box text color (white)\n        ],\n    }})"
  },
  {
    "objectID": "posts/phase-estimation/index.html#the-qft-circuit",
    "href": "posts/phase-estimation/index.html#the-qft-circuit",
    "title": "Quantum Phase Estimation",
    "section": "The QFT circuit",
    "text": "The QFT circuit\n\nCP-chains\nOne of the building blocks (subcircuits) of the QFT circuit consists of a composition of controlled phase gates. We will call these subcircuits CP-chains. In the following we will describe these CP-chains and give an explicit formula for how they map qubit states.\n\nPhase gates\nWe will write \\(P_\\phi\\) for the P-gate, which depends on a parameter \\(\\phi\\), that maps qubits as follows\n\\[\\begin{align*}\n    |0\\rangle & \\mapsto |0\\rangle\\\\\n    |1\\rangle & \\mapsto e^{\\phi i} |1\\rangle\n\\end{align*}\\] In other words, a P-gate applies a relative phase change to the \\(|1\\rangle\\) component of a qubit. If you prefer to describe gates by matrices, then \\[P_\\phi=\\begin{pmatrix}\n    1 & 0\\\\\n    0 & e^{\\phi i}\n\\end{pmatrix}\\]\nNote that we can get a little clever and write the P-gate mapping as \\[P_\\phi: |q\\rangle \\mapsto e^{q\\phi i}|q\\rangle\\] where \\(q\\in\\{0, 1\\}\\). The P-gate \\(P_{\\pi/2}\\) is pictured as follows:\n\n\nCode\nqc = QuantumCircuit(1)\nqc.p(pi/2, 0)\nqc.draw(output='mpl')\n\n\n\n\n\n\n\nControlled phase gates\nUsing the cleverness above, a controlled P-gate will map \\[CP_\\phi: |q_1q_0\\rangle \\mapsto e^{q_1q_0\\phi i}|q_1q_0\\rangle.\\]\nThe controlled P-gate \\(CP_{\\pi/2}\\) is drawn as follows:\n\n\nCode\nqc = QuantumCircuit(2)\nqc.cp(pi/2, 0, 1)\nqc.draw(output='mpl', reverse_bits=True)\n\n\n\n\n\n\n\nA chain of controlled phase gates\nSuppose we are concerned with a \\((n+1)\\)-qubit state space. Consider \\(n\\) CP-gates: \\(CP_{\\pi/2^k}\\) between the \\(n\\)-th and \\((n-k)\\)-th qubit for each \\(1\\leq k\\leq n\\). For example, when \\(n=4\\) the composition of these four CP-gates is the following:\n\n\nCode\ndef cpc(n):\n    qc = QuantumCircuit(n, name='   CPC   ')\n    for k in range(1, n):\n        qc.cp(pi/(2**k), n-1, n-1-k)\n    return qc\n\ncpc(5).draw(output='mpl', reverse_bits=True)\n\n\n\n\n\nI don’t know a standard name for the circuit above, so I’ll refer to the composition of these \\(n\\) CP-gates as the CP-chain, denoted \\(CPC_{n+1}\\). For example, the circuit drawn above is \\(CPC_5\\). Based on the mapping of \\(CP_\\phi\\) given above, it follows that the CP-chain maps \\(|a\\rangle=|a_n\\cdots a_1a_0\\rangle\\), the \\((n+1)\\)-qubit representation of an integer \\(0\\leq a< 2^{n+1}\\), as follows: \\[CPC_{n+1}:|a_na_{n-1}\\cdots a_1a_0\\rangle \\mapsto \\prod\\limits_{k=1}^ne^{\\frac{\\pi i\na_na_{n-k}}{2^k}}|a_na_{n-1}\\cdots a_1a_0\\rangle\\] To simplify the expression above, it will be useful to let \\(a'\\) denote the integer with \\(n\\)-qubit representation \\(|a'\\rangle=|a_{n-1}\\cdots a_1a_0\\rangle\\) so that \\(|a\\rangle=|a_n\\rangle\\otimes|a'\\rangle\\). With this notation, the amplitude above simplifies as \\[\\begin{align*}\n    \\prod\\limits_{k=1}^ne^{\\frac{\\pi i a_na_{n-k}}{2^k}}\n    & =e^{\\sum_{k=1}^n\\frac{\\pi i a_na_{n-k}}{2^k}} \\\\\n    & =e^{\\frac{\\pi i a_n}{2^n}\\sum_{k=1}^na_{n-k}2^{n-k}} \\\\\n    & =e^{\\frac{\\pi i a_n}{2^n}\\sum_{k=0}^{n-1}a_{k}2^{k}} \\\\\n    & =e^{\\frac{\\pi i a_na'}{2^n}}. \\\\\n\\end{align*}\\] Thus, the CP-chain mapping can be written as \\[\nCPC_{n+1}:|a_n\\rangle\\otimes|a'\\rangle \\mapsto e^{\\frac{\\pi i a_na'}{2^n}} |a_n\\rangle\\otimes|a'\\rangle.\n\\tag{4}\\]\n\n\n\nReverse circuits\nReversing the order of the qubits is another component of the QFT circuit. Reversing qubits can easily be accomplished using swap gates. The swap gate, pictured below, maps \\(|q_1q_0\\rangle\\to|q_0q_1\\rangle\\).\n\n\nCode\nqc = QuantumCircuit(2)\nqc.swap(0, 1)\nqc.draw(output='mpl', reverse_bits=True)\n\n\n\n\n\nWe let \\(Rev_n\\) for the \\(n\\)-qubit gate that reverses the qubit order. For example, \\(Rev_2\\) is the swap gate above. To obtain \\(Rev_n\\), one simply swaps the first and last qubit, the second and second to last qubit, and so on. For example, the following is \\(Rev_7\\):\n\n\nCode\ndef rev(n):\n    qc = QuantumCircuit(n, name='   Rev   ')\n    for i in range(n//2):\n        qc.swap(i, n-i-1)\n    return qc\n\nrev(7).draw(output='mpl', reverse_bits=True)\n\n\n\n\n\n\n\nA recursive formula for QFT\nWe are now in position to state recursive formula for the QFT that will allow use to build the QFT circuits:\n\\[\nQFT_{n+1} = Rev_{n+1}\\circ (I\\otimes (Rev_n\\circ QFT_n))\\circ CPC_{n+1}\\circ(H\\otimes I^{\\otimes n})\n\\tag{5}\\]\nThe formula above may be easier to visualize using circuits. Here is the recursively defined QFT circuit:\n\n\nCode\ndef qft(n):\n    qc = QuantumCircuit(n, name=f'  QFT  ')\n    qc.h(n-1)\n    if n == 1:\n        return qc\n    qc.append(cpc(n), range(n))\n    qc.append(qft(n-1), range(n-1))\n    qc.append(rev(n-1), range(n-1))\n    qc.append(rev(n), range(n))\n\n    return qc\n\nqft(5).draw(output='mpl', reverse_bits=True, style={\n    \"displaycolor\": {\n        \"   Rev   \": [ # gate name\n            \"#555555\", # box color (grey)\n            \"#FFFFFF\" # box text color (white)\n        ],\n        \"  QFT  \": [ # gate name\n            \"#da1e28\", # box color (red)\n            \"#FFFFFF\" # box text color (white)\n        ],\n    }})\n\n\n\n\n\n\n\nThe QFT circuit\nStarting with \\(QFT_1=H\\), the recursive formula 5 can be used to build all the QFT circuits in terms of H, CP, and swap gates. For example, here is \\(QFT_2\\):\n\n\nCode\nqc = QuantumCircuit(2)\nqc.h(1)\nqc.cp(pi/2, 1, 0)\nqc.h(0)\nqc.swap(0,1)\nqc.draw(output='mpl', reverse_bits=True)\n\n\n\n\n\nPlugging this into the recursive formula 5 gives us \\(QFT_3\\). After simplifying (Rev-gates are their own inverses) and expanding the CPC and Rev gates into CP and swap gates, we get the following for \\(QFT_3\\):\n\n\nCode\nqc = QuantumCircuit(3)\nqc.h(2)\nqc.cp(pi/2, 2, 1)\nqc.cp(pi/4, 2, 0)\nqc.h(1)\nqc.cp(pi/2, 1, 0)\nqc.h(0)\nqc.swap(0,2)\nqc.draw(output='mpl', reverse_bits=True)\n\n\n\n\n\nSimilarly, we can plug the QFT-circuit above into the recursive formula 5 and (after expanding and simplifying) get \\(QFT_4\\) in terms of H, CP, and swap gates:\n\n\nCode\nqc = QuantumCircuit(4)\nqc.h(3)\nqc.cp(pi/2, 3, 2)\nqc.cp(pi/4, 3, 1)\nqc.cp(pi/8, 3, 0)\nqc.h(2)\nqc.cp(pi/2, 2, 1)\nqc.cp(pi/4, 2, 0)\nqc.h(1)\nqc.cp(pi/2, 1, 0)\nqc.h(0)\nqc.swap(0,3)\nqc.swap(1,2)\nqc.draw(output='mpl', reverse_bits=True)\n\n\n\n\n\n\n\nA couple QFT computations with qiskit\nIn the code blocks above, the recursive formula 5 was used to create the QFT-circuit with qiskit. The following shows how to perform QFT calculations with qiskit. First, lets check that our circuit correctly computes \\(QFT_2|3\\rangle\\) (compare with 2 and 3).\n\nfrom qiskit.quantum_info import Statevector\nn = 2\na = 3\nstate_in = Statevector.from_int(a, 2**n)\nstate_out = state_in.evolve(qft(n))\nstate_out.draw('latex')\n\n\\[\\frac{1}{2} |00\\rangle- \\frac{i}{2} |01\\rangle- \\frac{1}{2} |10\\rangle+\\frac{i}{2} |11\\rangle\\]\n\n\nFor a slightly larger computation, let’s compute \\(QFT_3|7\\rangle\\):\n\nn = 3\na = 7\nstate_in = Statevector.from_int(a, 2**n)\nstate_out = state_in.evolve(qft(n))\nstate_out.draw('latex')\n\n\\[\\frac{\\sqrt{2}}{4} |000\\rangle+ (\\frac{1}{4} - \\frac{i}{4}) |001\\rangle- \\frac{\\sqrt{2} i}{4} |010\\rangle+ (- \\frac{1}{4} - \\frac{i}{4}) |011\\rangle- \\frac{\\sqrt{2}}{4} |100\\rangle+ (- \\frac{1}{4} + \\frac{i}{4}) |101\\rangle+\\frac{\\sqrt{2} i}{4} |110\\rangle+ (\\frac{1}{4} + \\frac{i}{4}) |111\\rangle\\]"
  },
  {
    "objectID": "posts/phase-estimation/index.html#proof-that-qft-satisfies-the-recursive-formula",
    "href": "posts/phase-estimation/index.html#proof-that-qft-satisfies-the-recursive-formula",
    "title": "Quantum Phase Estimation",
    "section": "Proof that QFT satisfies the recursive formula",
    "text": "Proof that QFT satisfies the recursive formula\nTo prove the recursive formula 5 we compute the output of the recursive circuit on an arbitrary \\((n+1)\\)-qubit representation of an integer: \\(|a\\rangle=|a_na_{n-1}\\cdots a_0\\rangle\\). In doing so, it will continue to use the notation from Section 2.1.3 by writing \\[\n|a\\rangle=|a_n\\rangle\\otimes|a'\\rangle.\n\\tag{6}\\] Following 5, we first apply the Hadamard gate (which is \\(QFT_1\\)) to the left (top) qubit: \\[\n|a_n\\rangle\\otimes|a'\\rangle \\mapsto \\dfrac{1}{\\sqrt{2}}\\sum_{0\\leq b_0\\leq 1}e^{\\pi i a_n b_0}|b_0\\rangle\\otimes|a'\\rangle.\n\\] Next, (according to 5) we apply the CPC-gate to the result and use 4 to get \\[\n\\dfrac{1}{\\sqrt{2}}\\sum_{0\\leq b_0\\leq 1}e^{\\pi i b_0 a_n}|b_0\\rangle\\otimes|a'\\rangle\\mapsto \\dfrac{1}{\\sqrt{2}}\\sum_{0\\leq b_0\\leq 1}e^{\\pi i b_0 a_n}e^{\\frac{\\pi i b_0 a'}{2^n}}|b_0\\rangle\\otimes|a'\\rangle.\n\\tag{7}\\] Since \\[\n2^na_n + a'=a\n\\tag{8}\\] (which follows from 6), the exponentials in the output of 7 can be simplified as follows: \\[\ne^{\\pi i b_0 a_n}e^{\\frac{\\pi i b_0 a'}{2^n}}=e^{\\frac{\\pi i b_0(2^na_n+a')}{2^n}}=e^{\\frac{\\pi i b_0 a}{2^n}}\n\\] Thus, the output of 7 can be written as \\[\n\\dfrac{1}{\\sqrt{2}}\\sum_{0\\leq b_0\\leq 1}e^{\\frac{\\pi i b_0 a}{2^n}}|b_0\\rangle\\otimes|a'\\rangle.\n\\] Next, (according to 5) we apply the QFT-gate to the right (bottom) \\(n\\) qubits using 1: \\[\n\\dfrac{1}{\\sqrt{2}}\\sum_{0\\leq b_0\\leq 1}e^{\\frac{\\pi i b_0 a}{2^n}}|b_0\\rangle\\otimes|a'\\rangle\n\\mapsto\n\\dfrac{1}{\\sqrt{2}}\\sum_{0\\leq b_0\\leq 1}e^{\\frac{\\pi i b_0 a}{2^n}}|b_0\\rangle\\otimes\\dfrac{1}{\\sqrt{2^n}}\\sum_{0\\leq b'<2^n}e^{\\frac{2\\pi i a'b'}{2^n}}|b'\\rangle.\n\\] If we write \\(|b'\\rangle=|b_nb_{n-1}\\cdots b_1\\rangle\\), then the output above can be written as \\[\n\\dfrac{1}{\\sqrt{2^{n+1}}}\\sum_{0\\leq b_0,b_1,\\ldots,b_n\\leq 1}e^{\\frac{\\pi i b_0 a}{2^n}}e^{\\frac{2\\pi i a'b'}{2^n}}|b_0\\rangle\\otimes|b_n\\cdots b_1\\rangle.\n\\] Now, (still following 5) we reverse the last (bottom) \\(n\\) qubits to get\n\\[\\begin{align*}\n& \\dfrac{1}{\\sqrt{2^{n+1}}}\\sum_{0\\leq b_0,b_1,\\ldots,b_n\\leq 1}e^{\\frac{\\pi i b_0 a}{2^n}}e^{\\frac{2\\pi i a'b'}{2^n}}|b_0\\rangle\\otimes|b_1\\cdots b_n\\rangle \\\\\n& =\\dfrac{1}{\\sqrt{2^{n+1}}}\\sum_{0\\leq b_0,b_1,\\ldots,b_n\\leq 1}e^{\\frac{\\pi i b_0 a}{2^n}}e^{\\frac{2\\pi i a'b'}{2^n}}|b_0b_1\\cdots b_n\\rangle. \\\\\n& =\\dfrac{1}{\\sqrt{2^{n+1}}}\\sum_{0\\leq b_0,b_1,\\ldots,b_n\\leq 1}e^{\\frac{\\pi i (ab_0+2a'b')}{2^n}}|b_0b_1\\cdots b_n\\rangle.\n\\end{align*} \\tag{9}\\]\nFinally, if we let \\(b\\) denote the integer with \\(|b\\rangle=|b_n\\cdots b_0\\rangle\\), then after we reverse all \\(n+1\\) qubits (the last step in 5) in 9 we get \\[\n\\dfrac{1}{\\sqrt{2^{n+1}}}\\sum_{0\\leq b_0,\\ldots,b_n\\leq 1}e^{\\frac{\\pi i (ab_0+2a'b')}{2^n}}|b_n\\cdots b_0\\rangle\n=\n\\dfrac{1}{\\sqrt{2^{n+1}}}\\sum_{b=0}^{2^{n+1}-1}e^{\\frac{\\pi i (ab_0+2a'b')}{2^n}}|b\\rangle.\n\\] The state above the output of the recursive gate 5 applied to \\(|a\\rangle\\). On the other hand, using 1 we get \\[\nQFT_{n+1}|a\\rangle = \\dfrac{1}{\\sqrt{2^{n+1}}}\\sum_{b=0}e^{2^{n+1}-1}e^{\\frac{2\\pi i ab}{2^{n+1}}}|b\\rangle.\n\\] Thus, to complete the proof it suffices to show \\[\ne^{\\frac{\\pi i (ab_0+2a'b')}{2^n}} = e^{\\frac{2\\pi i ab}{2^{n+1}}}\n\\] or equivalently \\[\ne^{\\frac{\\pi i (ab-ab_0-2a'b')}{2^{n}}} = 1.\n\\]\nSince \\(|b\\rangle=|b_n\\cdots b_1b_0\\rangle\\) and \\(|b'\\rangle=|b_n\\cdots b_1\\rangle\\), it follows that \\(b=2b'+b_0\\) so that \\(b-b_0=2b'\\). Using this fact along with \\(a-a'=2^na_n\\) (which follows from 8) we get the desired result: \\[\\begin{align*}\ne^{\\frac{\\pi i (ab-ab_0-2a'b')}{2^{n}}}\n& = e^{\\frac{\\pi i (2ab'-2a'b')}{2^{n}}} \\\\\n& = e^{\\frac{\\pi i (2(a-a')b')}{2^{n}}} \\\\\n& = e^{\\frac{\\pi i (2^{n+1}a_nb')}{2^{n}}}\\\\\n& = e^{2\\pi i a_nb'}\\\\\n& = 1.\n\\end{align*}\\]"
  },
  {
    "objectID": "posts/phase-estimation/index.html#the-quantum-phase-estimation-circuit",
    "href": "posts/phase-estimation/index.html#the-quantum-phase-estimation-circuit",
    "title": "Quantum Phase Estimation",
    "section": "The quantum phase estimation circuit",
    "text": "The quantum phase estimation circuit"
  },
  {
    "objectID": "posts/phase-estimation/index.html#inputting-an-eigenvector-to-the-phase-estimation-circuit",
    "href": "posts/phase-estimation/index.html#inputting-an-eigenvector-to-the-phase-estimation-circuit",
    "title": "Quantum Phase Estimation",
    "section": "Inputting an eigenvector to the phase estimation circuit",
    "text": "Inputting an eigenvector to the phase estimation circuit\nRecall that the goal of quantum phase estimation is to find \\(\\theta\\) where \\(e^{2\\pi i\\theta}\\) is an eigenvalue of \\(U\\). To see how the circuit 2 can help to accomplish this, we input \\(|0\\rangle^{\\otimes n}\\otimes|x\\rangle\\) where \\(|x\\rangle\\) is an eigenvector of \\(U\\) with eigenvalue \\(e^{2\\pi i\\theta}\\). First we apply the Hadamard \\(H\\) to the first (top) \\(n\\) qubits:\n\\[\\begin{align*}\n|0\\rangle^{\\otimes n}\\otimes|x\\rangle\n& \\mapsto \\left(\\frac{1}{\\sqrt{2}}(|0\\rangle+|1\\rangle\\right)^{\\otimes n}\\otimes|x\\rangle \\\\\n& = \\frac{1}{\\sqrt{2^n}}\\sum_{0\\leq b_0,\\ldots,b_{n-1}\\leq 1}|b_{n-1}\\cdots b_1b_0\\rangle \\otimes|x\\rangle \\\\\n\\end{align*} \\tag{3}\\] Following 2, next we apply \\(CU_{n-1}^{2^{n-1}}\\cdots CU_2^4CU_1^2CU_0\\). Using 1 we see the result of applying \\(CU_{n-1}^{2^{n-1}}\\cdots CU_2^4CU_1^2CU_0\\) to the output of 3 gives \\[\\begin{align*}\n& \\frac{1}{\\sqrt{2^n}}\\sum_{0\\leq b_0,\\ldots,b_{n-1}\\leq 1}\\prod_{k=0}^{n-1}e^{2\\pi i\\theta b_k 2^{k}}|b_{n-1}\\cdots b_1b_0\\rangle \\otimes|x\\rangle \\\\\n= & \\frac{1}{\\sqrt{2^n}}\\sum_{0\\leq b_0,\\ldots,b_{n-1}\\leq 1}e^{2\\pi i\\theta \\sum_{k=0}^{n-1}b_k 2^{k}}|b_{n-1}\\cdots b_1b_0\\rangle \\otimes|x\\rangle \\\\\n= & \\frac{1}{\\sqrt{2^n}}\\sum_{0\\leq b<2^{n}}e^{2\\pi i\\theta b}|b\\rangle \\otimes|x\\rangle \\\\\n\\end{align*} \\tag{4}\\] Setting \\(N=2^{n}\\), the left state in the tensor product 4 can be rewritten as \\[\n\\frac{1}{N}\\sum_{0\\leq b<N}e^{\\frac{2\\pi i N\\theta b}{N}}|b\\rangle.\n\\tag{5}\\] Now, since \\(0\\leq \\theta <1\\) we have \\(0\\leq N\\theta<N\\). If \\(N\\theta\\) happens to be an integer, then the expression 5 is exactly the output \\(QFT_n|N\\theta\\rangle\\) (see this post). In this case, when we compete the circuit 2 by applying \\((QFT^\\dagger_n\\otimes I)\\) to 4 the result is \\(|N\\theta\\rangle\\otimes|x\\rangle\\). Then we can measure the first (top) \\(n\\)-qubits to obtain \\(N\\theta\\). Note that since \\(N=2^n\\), these first \\(n\\) qubits will give the binary representation of \\(\\theta\\) up to a shift in the radix point. For example, if the first \\(n=3\\) qubits are in state \\(|011\\rangle\\), then \\(\\theta\\) has binary representation \\(0.011\\), so \\(\\theta=3/8\\). If \\(N\\theta\\) is not an integer, the result of measuring the first \\(n\\)-qubits will give an approximation \\(\\theta_n\\) for \\(\\theta\\). The difference \\(\\theta-\\theta_n\\) will approach 0 as \\(n\\to\\infty\\), so we can improve the approximation \\(\\theta_n\\approx\\theta\\) by picking a larger \\(n\\).\n\nExample: \\(U=Z\\)\nIn this example we let \\(U\\) denote the standard \\(Z\\)-gate so that \\(U=|0\\rangle\\langle0|-|1\\rangle\\langle1|\\). In this case we have an eigenvector \\(|x\\rangle=|0\\rangle\\) with eigenvalue \\(1\\), and thus \\(\\theta=0\\). Let’s use the phase estimation circuit with \\(n=2\\):\n\n\nCode\nn = 2\npe = phase_est(ZGate(), n)\n\npe.draw(output='mpl', reverse_bits=True, style={\n    \"displaycolor\": {\n        \"  QFT_dg\": [ # gate name\n            \"#da1e28\", # box color (red)\n            \"#FFFFFF\" # box text color (white)\n        ],\n    }})\n\n\n\n\n\nWe use the default input state \\(|00\\rangle\\otimes|x\\rangle=|000\\rangle\\), which we can implement in qiskit as follows:\n\nin_state = Statevector.from_int(0, 2**(n+1)) \nin_state.draw('latex')\n\n\\[ |000\\rangle\\]\n\n\nQiskit will compute the output, the result of applying the quantum phase estimation circuit to the state above, as follows:\n\nout_state = in_state.evolve(pe)\nout_state.draw('latex')\n\n\\[ |000\\rangle\\]\n\n\nThe first \\(n=2\\) qubits give \\(|00\\rangle=|N\\theta\\rangle\\). Thus we see \\(\\theta = 0\\), as expected.\nOn the other hand, \\(U=Z\\) also has an eigenvector \\(|x\\rangle=|1\\rangle\\) with eigenvalue \\(-1\\) (so \\(\\theta=1/2\\)). The following code will run the state \\(|00\\rangle\\otimes|x\\rangle=|001\\rangle\\) through the phase estimation circuit:\n\nin_state = Statevector.from_int(1, 2**(n+1)) \nout_state = in_state.evolve(pe)\nout_state.draw('latex')\n\n\\[ |101\\rangle\\]\n\n\nThis time the first \\(n=2\\) qubits gives \\(|10\\rangle=|N\\theta\\rangle\\), which means the binary representation of \\(\\theta\\) is \\(0.10\\), so \\(\\theta=1/2\\), as expected.\n\n\nExample: \\(U=T\\)\nIn this example we let \\(U\\) denote the standard \\(T\\)-gate so that \\(U=|0\\rangle\\langle0|+e^{\\pi i/4}|1\\rangle\\langle1|\\). Let us look at the eigenvector \\(|x\\rangle=|1\\rangle\\) which has eigenvalue \\(e^{\\pi i/4}\\), (so \\(\\theta=1/8\\)). Let’s start by using the phase estimation circuit with \\(n=2\\):\n\n\nCode\nn = 2\npe = phase_est(TGate(), n)\n\npe.draw(output='mpl', reverse_bits=True, style={\n    \"displaycolor\": {\n        \"  QFT_dg\": [ # gate name\n            \"#da1e28\", # box color (red)\n            \"#FFFFFF\" # box text color (white)\n        ],\n    }})\n\n\n\n\n\nIf we input the state \\(|00\\rangle\\otimes|x\\rangle=|001\\rangle\\), we get the following unpleasant looking output:\n\n\nCode\nin_state = Statevector.from_int(1, 2**(n+1)) \nout_state = in_state.evolve(pe)\nout_state.draw('latex')\n\n\n\\[(0.25 + 0.603553390593 i) |001\\rangle+ (0.25 - 0.603553390593 i) |011\\rangle+ (\\frac{1}{4} - \\frac{2^{\\frac{47}{191}} \\cdot 3^{\\frac{160}{191}} \\cdot 5^{\\frac{160}{573}} \\cdot 7^{\\frac{99}{191}} i}{21 \\pi^{\\frac{887}{573}}}) |101\\rangle+ (\\frac{1}{4} + \\frac{2^{\\frac{47}{191}} \\cdot 3^{\\frac{160}{191}} \\cdot 5^{\\frac{160}{573}} \\cdot 7^{\\frac{99}{191}} i}{21 \\pi^{\\frac{887}{573}}}) |111\\rangle\\]\n\n\nIf we to measure the first \\(n=2\\) qubits of that output, we see four states with the following probabilities:\n\n\nCode\nprob_dict = out_state.probabilities_dict()\nstates = list(prob_dict.keys())\nfirst_states = [s[:-1] for s in states]\nprobs = [prob_dict[s] for s in states]\nsns.barplot(x=first_states, y=probs)\n\n\n<AxesSubplot:>\n\n\n\n\n\nThe reason that we are seeing a somewhat complicated output (which you may not expect since \\(\\theta=1/8\\) is so uncomplicated) is that we have chosen \\(n=2\\), so that \\(N=2^n=4\\), which gives the non-integer \\(N\\theta=1/2\\). On the other hand, if we use a circuit with \\(n=3\\) we get something much nicer. Here’s the circuit:\n\n\nCode\nn = 3\npe = phase_est(TGate(), n)\n\npe.draw(output='mpl', reverse_bits=True, style={\n    \"displaycolor\": {\n        \"  QFT_dg\": [ # gate name\n            \"#da1e28\", # box color (red)\n            \"#FFFFFF\" # box text color (white)\n        ],\n    }})\n\n\n\n\n\nAnd here is the output when \\(n=3\\):\n\n\nCode\nin_state = Statevector.from_int(1, 2**(n+1)) \nout_state = in_state.evolve(pe)\nout_state.draw('latex')\n\n\n\\[ |0011\\rangle\\]\n\n\nIn this case, the first 3 qubits of the output are \\(|001\\rangle\\), so \\(0.001\\) is the binary representation of \\(\\theta\\), which gives \\(\\theta=1/8\\), as expected.\n\n\nExample: \\(U=P_{2\\pi/3}\\)\nIf the \\(\\theta\\) we’re searching for does not have a terminating binary representation, then the phase estimation circuit has no chance of outputting the exact value of \\(\\theta\\). For example, let \\(U=P_{2\\pi/3}\\) denote the phase gate given by \\(U=|0\\rangle\\langle0|+e^{2\\pi i/3}|1\\rangle\\langle1|\\). Let’s look at the eigenvector \\(|x\\rangle=|1\\rangle\\) with eigenvalue \\(e^{2\\pi i/3}\\), so that \\(\\theta = 1/3\\). In this case, \\(N\\theta=N/3\\) will not be an integer for any \\(N=2^n\\), so the phase estimation circuit will only give us an approximation for \\(\\theta\\), and we should see that approximation improving as \\(n\\) increases. For example, if we take \\(n=2\\), the phase estimation circuit will send \\(|00\\rangle\\otimes|x\\rangle=|001\\rangle\\) to the following superposition:\n\n\nCode\nu = PhaseGate(2*pi/3)\nn = 2\npe = phase_est(u, n)\nin_state = Statevector.from_int(1, 2**(n+1)) \nout_state = in_state.evolve(pe)\nout_state.draw('latex')\n\n\n\\[\\frac{1}{4} |001\\rangle+ (0.591506350946 + 0.591506350946 i) |011\\rangle- \\frac{\\sqrt{3} i}{4} |101\\rangle+ (0.158493649054 - 0.158493649054 i) |111\\rangle\\]\n\n\nMeasure the first \\(n=2\\) qubits of that output, we see all four states with the following probabilities:\n\n\nCode\nprob_dict = out_state.probabilities_dict()\nstates = list(prob_dict.keys())\nfirst_states = [s[:-1] for s in states]\nprobs = [prob_dict[s] for s in states]\nsns.barplot(x=first_states, y=probs)\n\n\n<AxesSubplot:>\n\n\n\n\n\nThe state with the highest probability, \\(|01\\rangle\\), leads to the best of the four approximations, namely the one with binary representation \\(0.01\\), i.e. \\(\\theta\\approx 1/4\\). To get a better approximation, we take \\(n=3\\) which leads to the following probabilities:\n\n\nCode\nn = 3\npe = phase_est(u, n)\nin_state = Statevector.from_int(1, 2**(n+1)) \nout_state = in_state.evolve(pe)\nprob_dict = out_state.probabilities_dict()\nstates = list(prob_dict.keys())\nfirst_states = [s[:-1] for s in states]\nprobs = [prob_dict[s] for s in states]\nsns.barplot(x=first_states, y=probs)\n\n\n<AxesSubplot:>\n\n\n\n\n\nThe highest probability leads us to the binary representation \\(0.011\\), which gives the approximation \\(\\theta\\approx 3/8\\).\nThe following plot shows the (decimal) approximations that the phase estimation circuit produces for \\(2\\leq n\\leq 12\\). Each point corresponds to a possible state obtained by measuring the first \\(n\\) qubits in the output of the phase estimation circuit. The size of each point corresponds to the state’s probability, and only those states with probability greater than one percent are shown. We can see that the estimates obtained are indeed approaching the true value \\(\\theta=1/3\\).\n\n\nCode\ndef scatter_phase_estimates(u, input_int=0, qubit_size=12, rare=0.01): \n    '''\n    Produces a scatter plot of the phases estimates.\n    '''\n    u_size = u.num_qubits\n    num_qbits = []\n    probs = []\n    thetas = []\n    for n in range(2, qubit_size + 1):\n        pe = phase_est(u, n)\n        in_state = Statevector.from_int(input_int, 2**(n+u_size)) \n        out_state = in_state.evolve(pe)\n        out_state.draw('latex')\n        prob_dict = out_state.probabilities_dict()\n        states = list(prob_dict.keys())\n        num_qbits += [n for s in states if prob_dict[s] > rare]\n        probs += [prob_dict[s] for s in states if prob_dict[s] > rare]\n        thetas += [int(f'{s[:-u_size]}', base=2)/2**n for s in states if prob_dict[s] > rare]\n    graph = sns.scatterplot(x=num_qbits, y=thetas, size=probs)\n    graph.set_xlabel( \"n\" , size = 12 )\n    graph.set_ylabel( \"Estimate of theta (decimal)\" , size = 12 )\n    plt.show()\n\nscatter_phase_estimates(PhaseGate(2*pi/3), input_int=1)"
  },
  {
    "objectID": "posts/sandbox/Untitled.html",
    "href": "posts/sandbox/Untitled.html",
    "title": "Jonny's Posts",
    "section": "",
    "text": "from qiskit import QuantumCircuit\nfrom qiskit.quantum_info import Statevector\nfrom math import pi\n\n\ndef cpc(n):\n    qc = QuantumCircuit(n, name='   CPC')\n    for k in range(1, n):\n        qc.cp(pi/(2**k), n-1, n-1-k)\n    return qc\n\ncpc(5).draw(output='mpl', reverse_bits=True)\n\n\n\n\n\ndef rev(n):\n    qc = QuantumCircuit(n, name='   Rev')\n    for i in range(n//2):\n        qc.swap(i, n-i-1)\n    return qc\n\nrev(7).draw(output='mpl', reverse_bits=True)\n\n\n\n\n\ndef qft(n):\n    qc = QuantumCircuit(n, name=f'  QFT')\n    qc.h(n-1)\n    if n == 1:\n        return qc\n    qc.append(cpc(n), range(n))\n    qc.append(qft(n-1), range(n-1))\n    qc.append(rev(n-1), range(n-1))\n    qc.append(rev(n), range(n))\n\n    return qc\n\nqft(5).draw(output='mpl', reverse_bits=True, style={\n    \"displaycolor\": {\n        \"   Rev\": [ # gate name\n            \"#555555\", # box color (grey)\n            \"#FFFFFF\" # box text color (white)\n        ],\n        \"  QFT\": [ # gate name\n            \"#da1e28\", # box color (red)\n            \"#FFFFFF\" # box text color (white)\n        ],\n    }})\n\n\n\n\n\nfrom qiskit import Aer, execute, transpile\n\n# Run the quantum circuit on a statevector simulator backend\n#backend = Aer.get_backend('statevector_simulator')\n\n# create circuit with measurement\nn = 2\ncirc = QuantumCircuit(n, n-1)\n\nqc = QuantumCircuit(n)\n# qc.y(0)\ncirc.append(qc, range(n))\ncirc.measure(range(1,n), range(n-1))\ncirc.draw(output='mpl', reverse_bits=True)\n\n\n\n\n\nfrom qiskit import Aer, transpile, QuantumCircuit\n\ncirc = QuantumCircuit(2)\ncirc.h(0)\ncirc.measure_all()\n\n# Transpile for simulator\nsimulator = Aer.get_backend('aer_simulator')\ncirc = transpile(circ, simulator)\n\n# Run and get counts\nresult = simulator.run(circ).result()\ncounts = result.get_counts(circ)\nprint(counts)\n\n\nimport qiskit.tools.jupyter\n%qiskit_version_table\n\n\nVersion InformationQiskit SoftwareVersionqiskit-terra0.22.3qiskit-aer0.11.2qiskit-ibmq-provider0.19.2qiskit0.39.3System informationPython version3.9.12Python compilerClang 12.0.0 Python buildmain, Apr  5 2022 01:53:17OSDarwinCPUs8Memory (Gb)8.0Mon Dec 12 12:27:38 2022 MST"
  },
  {
    "objectID": "posts/phase-estimation/index.html#inputting-non-eigenvectors-to-the-phase-estimation-circuit",
    "href": "posts/phase-estimation/index.html#inputting-non-eigenvectors-to-the-phase-estimation-circuit",
    "title": "Quantum Phase Estimation",
    "section": "Inputting non-eigenvectors to the phase estimation circuit",
    "text": "Inputting non-eigenvectors to the phase estimation circuit\n\n\nCode\nu = QuantumCircuit(2)\nu.h(0)\nu.ch(0,1)\nu.p(pi/6, 0)\nu.cp(pi/8, 1, 0)\nu.cy(0,1)\n\nu.draw(output='mpl', reverse_bits=True)\n\n\n\n\n\n\n\nCode\nu = u.to_gate()\nscatter_phase_estimates(u, qubit_size=11)"
  },
  {
    "objectID": "posts/phase-estimation/index.html#honest-phase-estimation-when-we-dont-already-know-the-eigenvalue",
    "href": "posts/phase-estimation/index.html#honest-phase-estimation-when-we-dont-already-know-the-eigenvalue",
    "title": "Quantum Phase Estimation",
    "section": "Honest phase estimation: when we don’t already know the eigenvalue",
    "text": "Honest phase estimation: when we don’t already know the eigenvalue\nSo far we have looked at what the phase estimation circuit does to an input of the form \\(|0\\rangle^{\\otimes n}\\otimes|x\\rangle\\) where \\(|x\\rangle\\) is an eigenvector of \\(U\\). But hang on, if we know an eigenvector \\(|x\\rangle\\) for \\(U\\), we can just compute \\(U|x\\rangle\\) to determine the corresponding \\(\\theta\\). Phase estimation is only useful if it can determine (an estimate) for the phase without already knowing eigenvectors. Luckily, since \\(U\\) is unitary it is diagonalizable (by a Spectral Theorem). In other words, \\(U\\) admits a basis of eigenvectors. In particular, for any vector \\(|x\\rangle\\) we can write \\[\n|x\\rangle = \\alpha_1|x_1\\rangle+\\alpha_2|x_2\\rangle+\\cdots+\\alpha_m|x_m\\rangle\n\\tag{6}\\] where \\(|x_1\\rangle,\\ldots,|x_m\\rangle\\) are all eigenvectors of \\(U\\). Thus, if we run \\(|x\\rangle\\) through the phase estimation circuit will have the effect of running all the eigenvectors that appear in 6, weighted depending on the \\(\\alpha_i\\)’s. For example, let \\(U\\) denote the gate corresponding to the following (essentially randomly chosen) circuit:\n\n\nCode\nu = QuantumCircuit(2)\nu.h(0)\nu.ch(0,1)\nu.p(pi/6, 0)\nu.cp(pi/8, 1, 0)\nu.cy(0,1)\n\nu.draw(output='mpl', reverse_bits=True)\n\n\n\n\n\nSince \\(U\\) corresponds to a \\(4\\times 4\\) matrix, we know \\(U\\) has at most 4 distinct eigenvalues. Let \\(|x\\rangle=|00\\rangle\\) (which is not an eigenvector of \\(U\\)). The following shows the phase estimates obtained from the phase estimate circuit by inputting \\(|0\\rangle^{\\otimes n}\\otimes|x\\rangle=|0\\cdots0\\rangle\\) for various values of \\(n\\)\n\n\nCode\nu = u.to_gate()\nscatter_phase_estimates(u)\n\n\n\n\n\nNote that after some initial noise, the phase estimates stabilize at 4 different values. These are the four values of \\(\\theta\\) corresponding to the 4 distinct eigenvalues of \\(U\\). As this example illustrates, the process of quantum phase estimation really can be used to discover eigenvalues of a unitary matrix."
  },
  {
    "objectID": "posts/quantum-computing-resources/index.html",
    "href": "posts/quantum-computing-resources/index.html",
    "title": "Quantum Computing Resources",
    "section": "",
    "text": "In this post I will list all the resources the I find useful while learning quantum computing. I’m sure there are many wonderful resources that are not listed below. My plan is to update this post whenever I find any!"
  },
  {
    "objectID": "posts/quantum-computing-resources/index.html#getting-started",
    "href": "posts/quantum-computing-resources/index.html#getting-started",
    "title": "Quantum Computing Resources",
    "section": "Getting Started",
    "text": "Getting Started\n\nBooks\n\nQuantum Computing for Everyone by Chris Berhardt. This is a wonderfully written introduction to quantum computing. As the title suggests, the book is aimed at non-experts. However, I found it incredibly useful when I was getting started. It does a great job of giving an overview of the subject while providing just enough rigor to make things really understandable.\nQuantum Computing: A Gentle Introduction by Eleanor Rieffel and Wolfgang Polak.\n\n\n\nOnline Tutorials and Resources\n\nQiskit Learn. In addition to the python-based software libraries, qiskit provides various other resources for learning quantum computing. In particular, there’s a qiskit textbook and some tutorials that I have found very useful.\n\n\n\nCoding\n\nQiskit\nIBM Quantum"
  },
  {
    "objectID": "posts/quantum-computing-resources/index.html#advanced-topics",
    "href": "posts/quantum-computing-resources/index.html#advanced-topics",
    "title": "Quantum Computing Resources",
    "section": "Advanced Topics",
    "text": "Advanced Topics\nComing later…"
  },
  {
    "objectID": "posts/Shors-algorithm-quantum-part/index.html",
    "href": "posts/Shors-algorithm-quantum-part/index.html",
    "title": "Shor’s Algorithm",
    "section": "",
    "text": "Code\nfrom qiskit import QuantumCircuit\nfrom qiskit.quantum_info.operators import Operator\nfrom qiskit.quantum_info import Statevector\nfrom math import pi\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport math\n\ndef cpc(n):\n    '''\n    Returns an n-qubit quantum circuit consisting of a chain \n    of CP-gates to use in the construction of the QFT circuit.\n    '''\n    qc = QuantumCircuit(n, name='   CPC')\n    for k in range(1, n):\n        qc.cp(pi/(2**k), n-1, n-1-k)\n    return qc\n\ndef rev(n):\n    '''\n    Returns an n-qubit quantum circuit that reverses \n    the order of the n qubits.\n    '''\n    qc = QuantumCircuit(n, name='   Rev')\n    for i in range(n//2):\n        qc.swap(i, n-i-1)\n    return qc\n\ndef qft(n):\n    '''\n    Returns the n-qubit QFT circuit.\n    '''\n    qc = QuantumCircuit(n, name=f'  QFT')\n    qc.h(n-1)\n    if n == 1:\n        return qc\n\n    qc.append(cpc(n), range(n))\n    qc.append(qft(n-1), range(n-1))\n    qc.append(rev(n-1), range(n-1))\n    qc.append(rev(n), range(n))\n    return qc\n\ndef phase_est(u, n):\n    '''\n    Returns the quantum circuit for phase estimation depending\n    on the gate u, extended with n-qubits. \n    If measure flag is True, will return with first (top)\n    measurement of first (top) n qubits.\n    '''\n    m = u.num_qubits\n    qc = QuantumCircuit(n+m)\n    \n    for i in range(n):\n        qc.h(m+i)\n    cu = u.control()\n    for i in range(n):\n        for _ in range(2**i):\n            qc.append(cu, [m+i] + list(range(m)))\n    qc.append(qft(n).inverse(), range(m, m+n))\n\n    return qc\n\ndef scatter_phase_estimates(u, input_int=0, qubit_size=12, rare=0.01): \n    '''\n    Produces a scatter plot of the phases estimates.\n    '''\n    u_size = u.num_qubits\n    num_qbits = []\n    probs = []\n    thetas = []\n    for n in range(2, qubit_size + 1):\n        pe = phase_est(u, n)\n        in_state = Statevector.from_int(input_int, 2**(n+u_size)) \n        out_state = in_state.evolve(pe)\n        out_state.draw('latex')\n        prob_dict = out_state.probabilities_dict()\n        states = list(prob_dict.keys())\n        num_qbits += [n for s in states if prob_dict[s] > rare]\n        probs += [prob_dict[s] for s in states if prob_dict[s] > rare]\n        thetas += [int(f'{s[:-u_size]}', base=2)/2**n for s in states if prob_dict[s] > rare]\n    graph = sns.scatterplot(x=num_qbits, y=thetas, size=probs)\n    graph.set_xlabel( \"n\" , size = 12 )\n    graph.set_ylabel( \"Estimate of theta (decimal)\" , size = 12 )\n    plt.show()\n\n\n\n\nCode\ndef u_matrix(a, N):\n    n = math.ceil(math.log(N, 2))\n    row = [0 for _ in range(2**n)]\n    mtx = [row[:] for _ in range(2**n)]\n    for j in range(N):\n        i = a*j % N\n        mtx[i][j] = 1\n    for i in range(N, 2**n):\n        mtx[i][i] = 1\n    return mtx\n\ndef u_gate(a, N):\n    n = math.ceil(math.log(N, 2))\n    circuit = QuantumCircuit(n)\n    u = Operator(u_matrix(a,N))\n    circuit.unitary(u, range(n), label='U')\n    return circuit.to_gate(label='U')\n\n\n\n\nCode\nN = 35\na = 3\nn = 4\nu = u_gate(a, N)\npe = phase_est(u, n)\nin_state = Statevector.from_int(1, 2**(n + math.ceil(math.log(N, 2))))\nout_state = in_state.evolve(pe)\nout_state.draw('latex')\n\n\n\\[\\frac{1}{8} |0000000001\\rangle+\\frac{1}{8} |0000000011\\rangle+\\frac{1}{16} |0000000100\\rangle+\\frac{1}{8} |0000001001\\rangle+\\frac{1}{16} |0000001011\\rangle+\\frac{1}{16} |0000001100\\rangle + \\ldots - \\frac{1}{16} |1111010000\\rangle+ (-0.057742470782 + 0.023917714523 i) |1111010001\\rangle+ (0.081660185305 + 0.033824756259 i) |1111011011\\rangle+ (- \\frac{125 \\cdot 2^{\\frac{101}{118}} \\cdot 3^{\\frac{31}{118}} \\cdot 5^{\\frac{13}{59}} \\cdot 7^{\\frac{45}{59}}}{5184 \\pi^{\\frac{109}{59}}} + \\frac{125 \\cdot 2^{\\frac{101}{118}} \\cdot 3^{\\frac{31}{118}} \\cdot 5^{\\frac{13}{59}} \\cdot 7^{\\frac{45}{59}} i}{5184 \\pi^{\\frac{109}{59}}}) |1111011101\\rangle+ (-0.023917714523 + 0.057742470782 i) |1111100001\\rangle\\]\n\n\n\n\nCode\nscatter_phase_estimates(u, input_int=1, qubit_size=6, rare=0.01)"
  },
  {
    "objectID": "posts.html",
    "href": "posts.html",
    "title": "Posts",
    "section": "",
    "text": "Twindragons and a Binary System for Complex Numbers\n\n\n\n\n\n\n\ntwindragon\n\n\nnumber systems\n\n\nfractals\n\n\n\n\n\n\n\n\n\n\n\nOct 21, 2023\n\n\nJonny Comes\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nQuantum Computing Resources\n\n\n\n\n\n\n\nquantum\n\n\nqiskit\n\n\nresources\n\n\n\n\n\n\n\n\n\n\n\nDec 17, 2022\n\n\nJonny Comes\n\n\n\n\n\n\n  \n\n\n\n\nQuantum Phase Estimation\n\n\n\n\n\n\n\nquantum\n\n\nqiskit\n\n\nQFT\n\n\nphase estimation\n\n\n\n\n\n\n\n\n\n\n\nDec 14, 2022\n\n\nJonny Comes\n\n\n\n\n\n\n  \n\n\n\n\nQuantum Fourier transform\n\n\n\n\n\n\n\nquantum\n\n\nqiskit\n\n\nQFT\n\n\n\n\n\n\n\n\n\n\n\nDec 2, 2022\n\n\nJonny Comes\n\n\n\n\n\n\n  \n\n\n\n\nQiskit: getting started\n\n\n\n\n\n\n\nquantum\n\n\nqiskit\n\n\n\n\n\n\n\n\n\n\n\nNov 28, 2022\n\n\nJonny Comes\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html#student-research-projects",
    "href": "index.html#student-research-projects",
    "title": "Jonny Comes",
    "section": "Student research projects",
    "text": "Student research projects\nOne of my favorite things I get to do at The College of Idaho is work with students on advanced undergraduate mathematics. I have several ideas for student projects that I’d be happy to explore with interested and motivated students. You can check out some of the projects I have supervised in the past here. If you are interested in (or just curious about) starting a project, please contact me. You can send me an email at jcomes@collegeofidaho.edu."
  },
  {
    "objectID": "index.html#a-bit-about-me",
    "href": "index.html#a-bit-about-me",
    "title": "Jonny Comes",
    "section": "A bit about me",
    "text": "A bit about me\nI am am Assistant Professor in Mathematics at The College of Idaho. I obtained my Ph.D. in mathematics from the University of Oregon in 2010 under the supervision of Victor Ostrik. Prior to that I got my B.A. and M.A., both in mathematics, at the University of Montana. If you’d like to know more about my professional background, take a look at my cv.\nThe majority of my research is in an area of mathematics called representation theory. I am particularly drawn to projects involving an interplay between combinatorial objects such as partitions or graphs and algebraic objects such as (super)groups or Lie (super)algebras. You can find out more about my research here."
  },
  {
    "objectID": "research.html",
    "href": "research.html",
    "title": "Research",
    "section": "",
    "text": "The majority of my research is in an area of pure mathematics called representation theory. I am usually drawn to projects involving an interplay between combinatorial objects such as partitions or graphs and algebraic objects such as (super)groups or Lie (super)algebras. I am particularly interested in diagram categories related to Brauer algebras and Deligne’s categories associated with representation theory in complex rank.\n\nPublications\n\nStuttering look and say sequences and a challenger to Conway’s most complicated algebraic number from the silliest source  preprint\n\n\nabstract\n\nWe introduce stuttering look and say sequences and describe their chemical structure in the spirit of Conway’s work on audioactive decay. We show the growth rate of a stuttering look and say sequence is an algebraic integer of degree 415.\n\nJellyfish partition categories  Algebras and Representation Theory, 23, 327-347 (2020).  journal arXiv\n\n\nabstract\n\nFor each positive integer \\(n\\), we introduce a monoidal category \\(\\mathcal{JP}(n)\\) using a generalization of partition diagrams. When the characteristic of the ground field is either 0 or at least \\(n\\), we show \\(\\mathcal{JP}(n)\\) is monoidally equivalent to the full subcategory of \\(\\operatorname{Rep}(A_n)\\) whose objects are tensor powers of the natural \\(n\\)-dimensional permutation representation of the alternating group \\(A_n.\\)\n\nA basis theorem for the degenerate affine oriented Brauer-Clifford supercategory  (with J. Brundan and J. Kujawa) Canadian Journal of Math., 71, 1061-1101 (2019).  journal arXiv\n\n\nabstract\n\nWe introduce the oriented Brauer-Clifford and degenerate affine oriented Brauer-Clifford supercategories. These are diagrammatically defined monoidal supercategories which provide combinatorial models for certain natural monoidal supercategories of supermodules and endosuperfunctors, respectively, for the Lie superalgebras of type Q. Our main results are basis theorems for these diagram supercategories. We also discuss connections and applications to the representation theory of the Lie superalgebra of type Q.\n\nThick ideals in Deligne’s category \\(\\underline{\\operatorname{Re}}\\!\\operatorname{p}(O_\\delta)\\)  (with T. Heidersdorf) Journal of Algebra, 480, 237-265 (2017).  journal arXiv\n\n\nabstract\n\nWe describe indecomposable objects in Deligne’s category \\(\\underline{\\operatorname{Re}}\\!\\operatorname{p}(O_\\delta)\\) and explain how to decompose their tensor products. We then classify thick ideals in \\(\\underline{\\operatorname{Re}}\\!\\operatorname{p}(O_\\delta)\\). As an application we classify the indecomposable summands of tensor powers of the standard representation of the orthosymplectic supergroup up to isomorphism.\n\nA basis theorem for the affine oriented Brauer category and its cyclotomic quotients  (with J. Brundan, D. Nash, and A. Reynolds) Quantum Topology, 8, 75-112 (2017).  journal arXiv\n\n\nabstract\n\nThe affine oriented Brauer category is a monoidal category obtained from the oriented Brauer category (= the free symmetric monoidal category generated by a single object and its dual) by adjoining a polynomial generator subject to appropriate relations. In this article, we prove a basis theorem for the morphism spaces in this category, as well as for all of its cyclotomic quotients.\n\nIdeals in Deligne’s tensor category \\(\\underline{\\operatorname{Re}}\\!\\operatorname{p}(GL_\\delta)\\)  Mathematical Research Letters, 21, 969-984 (2014).  journal arXiv\n\n\nabstract\n\nWe give a classification of ideals in \\(\\underline{\\operatorname{Re}}\\!\\operatorname{p}(GL_\\delta)\\)) for arbitrary \\(\\delta.\\)\n\nOn Deligne’s category \\(\\underline{\\operatorname{Re}}\\!\\operatorname{p}^{ab}(S_d)\\)  (with V. Ostrik) Algebra & Number Theory, 8, 473-496 (2014).  journal arXiv\n\n\nabstract\n\nWe prove a universal property of Deligne’s category \\(\\underline{\\operatorname{Re}}\\!\\operatorname{p}^{ab}(S_d)\\). Along the way, we classify tensor ideals in the category \\(\\underline{\\operatorname{Re}}\\!\\operatorname{p}(S_d).\\)\n\nDeligne’s category \\(\\underline{\\operatorname{Re}}\\!\\operatorname{p}(GL_\\delta)\\) and representations of general linear supergroups  (with B. Wilson) Representation Theory, 16, 568-609 (2012).  journal arXiv\n\n\nabstract\n\nWe classify indecomposable summands of mixed tensor powers of the natural representation for the general linear supergroup up to isomorphism. We also give a formula for the characters of these summands in terms of composite supersymmetric Schur polynomials, and give a method for decomposing their tensor products. Along the way, we describe indecomposable objects in \\(\\underline{\\operatorname{Re}}\\!\\operatorname{p}(GL_\\delta)\\) and explain how to decompose their tensor products.\n\nModified traces on Deligne’s category \\(\\underline{\\operatorname{Re}}\\!\\operatorname{p}(S_t)\\)  (with J. Kujawa) Journal of Algebraic Combinatorics, 36, 541-560 (2012).  journal arXiv\n\n\nabstract\n\nDeligne has defined a category which interpolates among the representations of the various symmetric groups. In this paper we show Deligne’s category admits a unique nontrivial family of modified trace functions. Such modified trace functions have already proven to be interesting in both low-dimensional topology and representation theory. We also introduce a graded variant of Deligne’s category, lift the modified trace functions to the graded setting, and use them to recover the well-known invariant of framed knots known as the writhe.\n\nOn blocks of Deligne’s category \\(\\underline{\\operatorname{Re}}\\!\\operatorname{p}(S_t)\\)  (with V. Ostrik) Advances in Mathematics, 226, 1331-1377 (2011).  journal arXiv\n\n\nabstract\n\nRecently P. Deligne introduced the tensor category \\(\\underline{\\operatorname{Re}}\\!\\operatorname{p}(S_t)\\) (for \\(t\\) not necessarily an integer) which in a certain precise sense interpolates the categories \\(\\operatorname{Rep}(S_d)\\) of representations of the symmetric groups \\(S_d\\). In this paper we describe the blocks of Deligne’s category \\(\\underline{\\operatorname{Re}}\\!\\operatorname{p}(S_t).\\)"
  },
  {
    "objectID": "publications.html",
    "href": "publications.html",
    "title": "Publications",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Authors\n        \n         \n          Year\n        \n         \n          Journal\n        \n         \n          ArXiv\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\nTitle\n\n\nAuthors\n\n\nYear\n\n\nJournal\n\n\nArXiv\n\n\n\n\n\n\nStuttering look and say sequences and a challenger to Conway’s most complicated algebraic number from the silliest source\n\n\nComes\n\n\n2022\n\n\npreprint\n\n\n2206.11991\n\n\n\n\nJellyfish partition categories\n\n\nComes\n\n\n2020\n\n\nAlgebras and Representation Theory, 23, 327-347\n\n\n1612.05182\n\n\n\n\nA basis theorem for the degenerate affine oriented Brauer-Clifford supercategoy\n\n\nBrundan, Comes, Kujawa\n\n\n2019\n\n\nCanadian Journal of Math., 71, 1061-1101\n\n\n1706.09999\n\n\n\n\nThick ideals in Deligne’s category Rep\\((O_\\delta)\\)\n\n\nComes, Heidersdorf\n\n\n2017\n\n\nJournal of Algebra, 480, 237-265\n\n\n1507.06728\n\n\n\n\nA basis theorem for the affine oriented Brauer category and its cyclotomic quotients\n\n\nBrundan, Comes, Nash, Reynolds\n\n\n2017\n\n\nQuantum Topology, 8, 75-112\n\n\n1404.6574\n\n\n\n\nIdeals in Deligne’s tensor category Rep\\((GL_\\delta)\\)\n\n\nComes\n\n\n2014\n\n\nMathematical Research Letters, 21, 969-984\n\n\n1201.5669\n\n\n\n\nOn Deligne’s category Rep\\(^{ab}(S_d)\\)\n\n\nComes, Ostrik\n\n\n2014\n\n\nAlgebra & Number Theory, 8, 473-496\n\n\n1304.3491\n\n\n\n\nDeligne’s category Rep\\((GL_\\delta)\\) and representations of general linear supergroups\n\n\nComes, Wilson\n\n\n2012\n\n\nRepresentation Theory, 16, 568-609\n\n\n1108.0652\n\n\n\n\nModified traces on Deligne’s category Rep\\((S_t)\\)\n\n\nComes, Kujawa\n\n\n2012\n\n\nJournal of Algebraic Combinatorics, 36, 541-560\n\n\n1103.2082\n\n\n\n\nOn blocks of Deligne’s category Rep\\((S_t)\\)\n\n\nComes, Ostrik\n\n\n2011\n\n\nAdvances in Mathematics, 226, 1331-1377\n\n\n0910.5695\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "students.html",
    "href": "students.html",
    "title": "Student Projects",
    "section": "",
    "text": "One of my favorite things to do at The College of Idaho is work with students on advanced undergraduate mathematics. You can check out some of the projects I have supervised in the past below. I have several ideas for student projects that I’d be happy to explore with interested and motivated students."
  },
  {
    "objectID": "students.html#list-of-student-projects-i-supervised",
    "href": "students.html#list-of-student-projects-i-supervised",
    "title": "Student Projects",
    "section": "List of student projects I supervised",
    "text": "List of student projects I supervised\n\n\\(n\\)th Root 2 Binary Look and Say Sequences\nSantosh Acharya & Aspram Kharatyan (2021-22)\nThis project was completed during the Math Capstone course in the Fall of 2021. Santosh and Aspram explored various nonstandard look and say sequences coming from nonstandard binary number systems using base \\(\\sqrt[n]{2}\\) for various positive integers \\(n.\\) Their results include descriptions of the growth rates chemistry of the squences for particular seeds, as well as a Cosmological Lemma which can be used to completely describe the chemistry for all seeds at any particular choice of \\(n\\). Santosh and Aspram wrote up the details of their work in a paper and presented a poster summarizing their work at the 2022 SRC.  (paper | poster)\n\n\nFactor groups of Knot and LOG groups\nSamuel Chandler (2015 - 2017)\nThis project started as a summer reading on knot theory using The Knot Book by Adams. The following academic year, Sam learned to code in a computer algebra system called GAP in order to study factor groups of knot groups. Sam also studied quotients of generalizations of knot groups that arise from labeled oriented graphs. Sam presented his work at the 2016 SRC.  (poster)\n\n\nApplications of Galois Theory to Differential Equations\nColton Grainger (2016)\nColton worked through the beautiful text Galois’ Dream: Group Theory and Differential Equations by Michio Kuga. This required Colton to apply methods from topology, algebra, and complex analysis in order to obtain a deeper understanding of the theory of differential equations. Colton presented examples at the 2016 SRC.  [ poster ]\n\n\nGenerators and relations for the Motzkin category\nJacob Karn (2016)\nThis project was an introduction to diagram categories. Jake worked through a draft of notes that I wrote, and ultimately proved a theorem which gives a nice presentation of the Motzkin category. Jake presented his work at the 2016 SRC.  [ poster ]\nYou can find a copy of my incomplete notes on diagram categories here. I’d like to work on them further at some point…"
  },
  {
    "objectID": "students.html#student-projects-i-supervised",
    "href": "students.html#student-projects-i-supervised",
    "title": "Student Projects",
    "section": "Student projects I Supervised",
    "text": "Student projects I Supervised\n\n\\(n\\)th Root 2 Binary Look and Say Sequences\nSantosh Acharya & Aspram Kharatyan (2021-22)\nThis project was completed during the Math Capstone course in the Fall of 2021. Santosh and Aspram explored various nonstandard look and say sequences coming from nonstandard binary number systems using base \\(\\sqrt[n]{2}\\) for various positive integers \\(n.\\) Their results include descriptions of the growth rates chemistry of the squences for particular seeds, as well as a Cosmological Lemma which can be used to completely describe the chemistry for all seeds at any particular choice of \\(n\\). Santosh and Aspram wrote up the details of their work in a paper and presented a poster summarizing their work at the 2022 SRC.  (paper | poster)\n\n\nFactor groups of Knot and LOG groups\nSamuel Chandler (2015 - 2017)\nThis project started as a summer reading on knot theory using The Knot Book by Adams. The following academic year, Sam learned to code in a computer algebra system called GAP in order to study factor groups of knot groups. Sam also studied quotients of generalizations of knot groups that arise from labeled oriented graphs. Sam presented his work at the 2016 SRC.  (poster)\n\n\nApplications of Galois Theory to Differential Equations\nColton Grainger (2016)\nColton worked through the beautiful text Galois’ Dream: Group Theory and Differential Equations by Michio Kuga. This required Colton to apply methods from topology, algebra, and complex analysis in order to obtain a deeper understanding of the theory of differential equations. Colton presented examples at the 2016 SRC.  [ poster ]\n\n\nGenerators and relations for the Motzkin category\nJacob Karn (2016)\nThis project was an introduction to diagram categories. Jake worked through a draft of notes that I wrote, and ultimately proved a theorem which gives a nice presentation of the Motzkin category. Jake presented his work at the 2016 SRC.  [ poster ]\nYou can find a copy of my incomplete notes on diagram categories here. I’d like to work on them further at some point…"
  },
  {
    "objectID": "students.html#my-students-projects",
    "href": "students.html#my-students-projects",
    "title": "Student Projects",
    "section": "My Students’ Projects",
    "text": "My Students’ Projects\n\nA Basis Theorem for the Jellyfish Brauer Category \\(JB(2)\\)\nEthan Bassingthwaite, Ryan Blau, Michael Coleman, and Julene Elias (2023)\nIn the Spring of 2023, this jellyfish crew studied the diagram category \\(JB(2)\\) which is equivalent to the full tensor subcategory of Rep(SO(2)) generated by the natural 2-dimensional representation of the special orthogonal group SO(2). The main result of the project was a diagram basis for \\(JB(2)\\) in terms of dotted Temperley-Lieb diagrams. They wrote up their result nicely in a paper.  paper\n\n\nA Python Proof of Conway’s Cosmological Theorem\nEthan Bassingthwaite and Monika de los Rios (2022)\nIn the Spring of 2022, Ethan and Monika implemented a proof of John Conway’s Cosmological Theorem using Python. We followed the strategy of Zeilberger’s proof with implementation similar to that of Litherland. This proof was subsequently added to the Python module I wrote called look_and_say.  documentation\n\n\n\\(n\\)th Root 2 Binary Look and Say Sequences\nSantosh Acharya and Aspram Kharatyan (2021-22)\nThis project was completed during the Math Capstone course in the Fall of 2021. Santosh and Aspram explored various nonstandard look and say sequences coming from nonstandard binary number systems using base \\(\\sqrt[n]{2}\\) for various positive integers \\(n.\\) Their results include descriptions of the growth rates and chemistry of the squences for particular seeds, as well as a Cosmological Lemma which can be used to completely describe the chemistry for all seeds at any particular choice of \\(n\\). Santosh and Aspram wrote up the details of their work in a paper and presented a poster summarizing their work at the 2022 SRC.  paper poster\n\n\nHigher Dimensional Twindragons via Quaternions\nAlex Tarasenko (2019 - 2020)\nThis project started with a reading course in the Fall of 2019 on Measure, Topology, and Fractal Geometry by Edgar. A particularly beautiful topic in that book is the connection between various representations of complex numbers and fractilings of the complex plane. The following spring, Alex explored higher dimensional analogs of this topic by replacing the 2-dimensional complex numbers with the 4-dimensional quaternion algebra (the Hamiltonians). Alex presented his results at the 2020 SRC. Unfortunately, I do not have a copy of Alex’s poster to share.\n\n\nFactor groups of Knot and LOG groups\nSamuel Chandler (2015 - 2017)\nThis project started as a summer reading on knot theory using The Knot Book by Adams. The following academic year, Sam learned to code in a computer algebra system called GAP in order to study factor groups of knot groups. Sam also studied quotients of generalizations of knot groups that arise from labeled oriented graphs. Sam presented his work at the 2016 SRC.  poster\n\n\nApplications of Galois Theory to Differential Equations\nColton Grainger (2016)\nColton worked through the beautiful text Galois’ Dream: Group Theory and Differential Equations by Michio Kuga. This required Colton to apply methods from topology, algebra, and complex analysis in order to obtain a deeper understanding of the theory of differential equations. Colton presented examples at the 2016 SRC.  poster\n\n\nGenerators and relations for the Motzkin category\nJacob Karn (2016)\nThis project was an introduction to diagram categories. Jake worked through a draft of notes that I wrote, and ultimately proved a theorem which gives a nice presentation of the Motzkin category. Jake presented his work at the 2016 SRC.  poster"
  },
  {
    "objectID": "students.html#resources-written-for-student",
    "href": "students.html#resources-written-for-student",
    "title": "Student Projects",
    "section": "Resources written for student",
    "text": "Resources written for student\nComing soon…"
  },
  {
    "objectID": "students.html#resources-written-for-students",
    "href": "students.html#resources-written-for-students",
    "title": "Student Projects",
    "section": "Resources written for students",
    "text": "Resources written for students\nComing soon…"
  },
  {
    "objectID": "students.html#resources-for-my-students",
    "href": "students.html#resources-for-my-students",
    "title": "Student Projects",
    "section": "Resources for My Students",
    "text": "Resources for My Students\n\nNotes on Diagram Categories\nBack in 2017 I wrote some notes to introduce undergraduates to diagram categories. The notes do not assume the reader has any experience with category theory, or even abstract algebra. The notes were intended to include a second part on Linear Diagram Categories, but that part was never realized. Perhaps some day I will go back and add this part, but the current version is still (I hope) a useful introduction to the topic.  notes\n\n\nAn Introduction to Nonstandard Look and Say Sequence\nThese notes were written to introduce students to the theory of look and say sequences in the spirit of John Conway’s paper The Weird and Wonderful Chemistry of Audioactive Decay. The notes are not meant as a replacement for Conway’s delightful explanation of his methods and results. Instead, they are meant to explain how Conway’s methods and results can be generalized to other (nonstandard) look and say sequences.  notes\n\n\nThe Python look_and_say module\nI wrote a Python module that students (or anyone else) can use to explore nonstandard look and say sequences in the spirit of John Conway.  PyPI documentation GitHub Repo"
  },
  {
    "objectID": "index.html#education",
    "href": "index.html#education",
    "title": "Jonny Comes",
    "section": "Education",
    "text": "Education\nUniversity of Oregon | Eugene, OR  PhD in Mathematics | 2010\nUniversity of Montana | Missoula, MT  M.A. in Mathematics | 2004  B.A. in Mathematics | 2003"
  },
  {
    "objectID": "index.html#experience",
    "href": "index.html#experience",
    "title": "Jonny Comes",
    "section": "Experience",
    "text": "Experience\nIn addition to working at The College of Idaho, I have held various visiting research and teaching positions at The Technical University of Munich, The University of Oregon, Lewis and Clark College, and The Max Planck Institute for Mathematics in Bonn.\n\n\nresearch\n\n\nstudent projects\n\n\nblog\n\n\nGithub\n\n\nLinkedIn"
  },
  {
    "objectID": "index.html#previous-experience",
    "href": "index.html#previous-experience",
    "title": "Jonny Comes",
    "section": "Previous Experience",
    "text": "Previous Experience\nIn addition to working at The College of Idaho, I have held various visiting research and teaching positions at The Technical University of Munich, The University of Oregon, Lewis and Clark College, and The Max Planck Institute for Mathematics in Bonn."
  },
  {
    "objectID": "posts/twindragon-binary/index.html",
    "href": "posts/twindragon-binary/index.html",
    "title": "Twindragons and a Binary System for Complex Numbers",
    "section": "",
    "text": "This post is not about the standard binary number system, but it’s a decent place to start the discussion. In standard binary, every integer is represented by a string of 1’s and 0’s. To determine which integer is represented by a given string we translate the string into a sum of powers of 2. For example, in the standard binary system \\(\\textcolor{#17a2b8}{1100}\\) represents the integer \\[\\textcolor{#17a2b8}{1}\\cdot2^3+\\textcolor{#17a2b8}{1}\\cdot2^2+\\textcolor{#17a2b8}{0}\\cdot2^1+\\textcolor{#17a2b8}{0}\\cdot2^0,\\] which (in the standard decimal system) is 12. Since the representation of numbers relies on powers of 2, we say that the standard binary system uses base 2."
  },
  {
    "objectID": "posts/twindragon-binary/index.html#inputting-an-eigenvector-to-the-phase-estimation-circuit",
    "href": "posts/twindragon-binary/index.html#inputting-an-eigenvector-to-the-phase-estimation-circuit",
    "title": "Twindragons and a Binary System for Complex Numbers",
    "section": "Inputting an eigenvector to the phase estimation circuit",
    "text": "Inputting an eigenvector to the phase estimation circuit\nRecall that the goal of quantum phase estimation is to find \\(\\theta\\) where \\(e^{2\\pi i\\theta}\\) is an eigenvalue of \\(U\\). To see how the circuit 2 can help to accomplish this, we input \\(|0\\rangle^{\\otimes n}\\otimes|x\\rangle\\) where \\(|x\\rangle\\) is an eigenvector of \\(U\\) with eigenvalue \\(e^{2\\pi i\\theta}\\). First we apply the Hadamard \\(H\\) to the first (top) \\(n\\) qubits:\n\\[\\begin{align*}\n|0\\rangle^{\\otimes n}\\otimes|x\\rangle\n& \\mapsto \\left(\\frac{1}{\\sqrt{2}}(|0\\rangle+|1\\rangle\\right)^{\\otimes n}\\otimes|x\\rangle \\\\\n& = \\frac{1}{\\sqrt{2^n}}\\sum_{0\\leq b_0,\\ldots,b_{n-1}\\leq 1}|b_{n-1}\\cdots b_1b_0\\rangle \\otimes|x\\rangle \\\\\n\\end{align*} \\tag{3}\\] Following 2, next we apply \\(CU_{n-1}^{2^{n-1}}\\cdots CU_2^4CU_1^2CU_0\\). Using 1 we see the result of applying \\(CU_{n-1}^{2^{n-1}}\\cdots CU_2^4CU_1^2CU_0\\) to the output of 3 gives \\[\\begin{align*}\n& \\frac{1}{\\sqrt{2^n}}\\sum_{0\\leq b_0,\\ldots,b_{n-1}\\leq 1}\\prod_{k=0}^{n-1}e^{2\\pi i\\theta b_k 2^{k}}|b_{n-1}\\cdots b_1b_0\\rangle \\otimes|x\\rangle \\\\\n= & \\frac{1}{\\sqrt{2^n}}\\sum_{0\\leq b_0,\\ldots,b_{n-1}\\leq 1}e^{2\\pi i\\theta \\sum_{k=0}^{n-1}b_k 2^{k}}|b_{n-1}\\cdots b_1b_0\\rangle \\otimes|x\\rangle \\\\\n= & \\frac{1}{\\sqrt{2^n}}\\sum_{0\\leq b<2^{n}}e^{2\\pi i\\theta b}|b\\rangle \\otimes|x\\rangle \\\\\n\\end{align*} \\tag{4}\\] Setting \\(N=2^{n}\\), the left state in the tensor product 4 can be rewritten as \\[\n\\frac{1}{N}\\sum_{0\\leq b<N}e^{\\frac{2\\pi i N\\theta b}{N}}|b\\rangle.\n\\tag{5}\\] Now, since \\(0\\leq \\theta <1\\) we have \\(0\\leq N\\theta<N\\). If \\(N\\theta\\) happens to be an integer, then the expression 5 is exactly the output \\(QFT_n|N\\theta\\rangle\\) (see this post). In this case, when we compete the circuit 2 by applying \\((QFT^\\dagger_n\\otimes I)\\) to 4 the result is \\(|N\\theta\\rangle\\otimes|x\\rangle\\). Then we can measure the first (top) \\(n\\)-qubits to obtain \\(N\\theta\\). Note that since \\(N=2^n\\), these first \\(n\\) qubits will give the binary representation of \\(\\theta\\) up to a shift in the radix point. For example, if the first \\(n=3\\) qubits are in state \\(|011\\rangle\\), then \\(\\theta\\) has binary representation \\(0.011\\), so \\(\\theta=3/8\\). If \\(N\\theta\\) is not an integer, the result of measuring the first \\(n\\)-qubits will give an approximation \\(\\theta_n\\) for \\(\\theta\\). The difference \\(\\theta-\\theta_n\\) will approach 0 as \\(n\\to\\infty\\), so we can improve the approximation \\(\\theta_n\\approx\\theta\\) by picking a larger \\(n\\).\n\nExample: \\(U=Z\\)\nIn this example we let \\(U\\) denote the standard \\(Z\\)-gate so that \\(U=|0\\rangle\\langle0|-|1\\rangle\\langle1|\\). In this case we have an eigenvector \\(|x\\rangle=|0\\rangle\\) with eigenvalue \\(1\\), and thus \\(\\theta=0\\). Let’s use the phase estimation circuit with \\(n=2\\):\n\n\nCode\nn = 2\npe = phase_est(ZGate(), n)\n\npe.draw(output='mpl', reverse_bits=True, style={\n    \"displaycolor\": {\n        \"  QFT_dg\": [ # gate name\n            \"#da1e28\", # box color (red)\n            \"#FFFFFF\" # box text color (white)\n        ],\n    }})\n\n\n\n\n\nWe use the default input state \\(|00\\rangle\\otimes|x\\rangle=|000\\rangle\\), which we can implement in qiskit as follows:\n\nin_state = Statevector.from_int(0, 2**(n+1)) \nin_state.draw('latex')\n\n\\[ |000\\rangle\\]\n\n\nQiskit will compute the output, the result of applying the quantum phase estimation circuit to the state above, as follows:\n\nout_state = in_state.evolve(pe)\nout_state.draw('latex')\n\n\\[ |000\\rangle\\]\n\n\nThe first \\(n=2\\) qubits give \\(|00\\rangle=|N\\theta\\rangle\\). Thus we see \\(\\theta = 0\\), as expected.\nOn the other hand, \\(U=Z\\) also has an eigenvector \\(|x\\rangle=|1\\rangle\\) with eigenvalue \\(-1\\) (so \\(\\theta=1/2\\)). The following code will run the state \\(|00\\rangle\\otimes|x\\rangle=|001\\rangle\\) through the phase estimation circuit:\n\nin_state = Statevector.from_int(1, 2**(n+1)) \nout_state = in_state.evolve(pe)\nout_state.draw('latex')\n\n\\[ |101\\rangle\\]\n\n\nThis time the first \\(n=2\\) qubits gives \\(|10\\rangle=|N\\theta\\rangle\\), which means the binary representation of \\(\\theta\\) is \\(0.10\\), so \\(\\theta=1/2\\), as expected.\n\n\nExample: \\(U=T\\)\nIn this example we let \\(U\\) denote the standard \\(T\\)-gate so that \\(U=|0\\rangle\\langle0|+e^{\\pi i/4}|1\\rangle\\langle1|\\). Let us look at the eigenvector \\(|x\\rangle=|1\\rangle\\) which has eigenvalue \\(e^{\\pi i/4}\\), (so \\(\\theta=1/8\\)). Let’s start by using the phase estimation circuit with \\(n=2\\):\n\n\nCode\nn = 2\npe = phase_est(TGate(), n)\n\npe.draw(output='mpl', reverse_bits=True, style={\n    \"displaycolor\": {\n        \"  QFT_dg\": [ # gate name\n            \"#da1e28\", # box color (red)\n            \"#FFFFFF\" # box text color (white)\n        ],\n    }})\n\n\n\n\n\nIf we input the state \\(|00\\rangle\\otimes|x\\rangle=|001\\rangle\\), we get the following unpleasant looking output:\n\n\nCode\nin_state = Statevector.from_int(1, 2**(n+1)) \nout_state = in_state.evolve(pe)\nout_state.draw('latex')\n\n\n\\[(0.25 + 0.603553390593 i) |001\\rangle+ (0.25 - 0.603553390593 i) |011\\rangle+ (\\frac{1}{4} - \\frac{2^{\\frac{47}{191}} \\cdot 3^{\\frac{160}{191}} \\cdot 5^{\\frac{160}{573}} \\cdot 7^{\\frac{99}{191}} i}{21 \\pi^{\\frac{887}{573}}}) |101\\rangle+ (\\frac{1}{4} + \\frac{2^{\\frac{47}{191}} \\cdot 3^{\\frac{160}{191}} \\cdot 5^{\\frac{160}{573}} \\cdot 7^{\\frac{99}{191}} i}{21 \\pi^{\\frac{887}{573}}}) |111\\rangle\\]\n\n\nIf we to measure the first \\(n=2\\) qubits of that output, we see four states with the following probabilities:\n\n\nCode\nprob_dict = out_state.probabilities_dict()\nstates = list(prob_dict.keys())\nfirst_states = [s[:-1] for s in states]\nprobs = [prob_dict[s] for s in states]\nsns.barplot(x=first_states, y=probs)\n\n\n<AxesSubplot:>\n\n\n\n\n\nThe reason that we are seeing a somewhat complicated output (which you may not expect since \\(\\theta=1/8\\) is so uncomplicated) is that we have chosen \\(n=2\\), so that \\(N=2^n=4\\), which gives the non-integer \\(N\\theta=1/2\\). On the other hand, if we use a circuit with \\(n=3\\) we get something much nicer. Here’s the circuit:\n\n\nCode\nn = 3\npe = phase_est(TGate(), n)\n\npe.draw(output='mpl', reverse_bits=True, style={\n    \"displaycolor\": {\n        \"  QFT_dg\": [ # gate name\n            \"#da1e28\", # box color (red)\n            \"#FFFFFF\" # box text color (white)\n        ],\n    }})\n\n\n\n\n\nAnd here is the output when \\(n=3\\):\n\n\nCode\nin_state = Statevector.from_int(1, 2**(n+1)) \nout_state = in_state.evolve(pe)\nout_state.draw('latex')\n\n\n\\[ |0011\\rangle\\]\n\n\nIn this case, the first 3 qubits of the output are \\(|001\\rangle\\), so \\(0.001\\) is the binary representation of \\(\\theta\\), which gives \\(\\theta=1/8\\), as expected.\n\n\nExample: \\(U=P_{2\\pi/3}\\)\nIf the \\(\\theta\\) we’re searching for does not have a terminating binary representation, then the phase estimation circuit has no chance of outputting the exact value of \\(\\theta\\). For example, let \\(U=P_{2\\pi/3}\\) denote the phase gate given by \\(U=|0\\rangle\\langle0|+e^{2\\pi i/3}|1\\rangle\\langle1|\\). Let’s look at the eigenvector \\(|x\\rangle=|1\\rangle\\) with eigenvalue \\(e^{2\\pi i/3}\\), so that \\(\\theta = 1/3\\). In this case, \\(N\\theta=N/3\\) will not be an integer for any \\(N=2^n\\), so the phase estimation circuit will only give us an approximation for \\(\\theta\\), and we should see that approximation improving as \\(n\\) increases. For example, if we take \\(n=2\\), the phase estimation circuit will send \\(|00\\rangle\\otimes|x\\rangle=|001\\rangle\\) to the following superposition:\n\n\nCode\nu = PhaseGate(2*pi/3)\nn = 2\npe = phase_est(u, n)\nin_state = Statevector.from_int(1, 2**(n+1)) \nout_state = in_state.evolve(pe)\nout_state.draw('latex')\n\n\n\\[\\frac{1}{4} |001\\rangle+ (0.591506350946 + 0.591506350946 i) |011\\rangle- \\frac{\\sqrt{3} i}{4} |101\\rangle+ (0.158493649054 - 0.158493649054 i) |111\\rangle\\]\n\n\nMeasure the first \\(n=2\\) qubits of that output, we see all four states with the following probabilities:\n\n\nCode\nprob_dict = out_state.probabilities_dict()\nstates = list(prob_dict.keys())\nfirst_states = [s[:-1] for s in states]\nprobs = [prob_dict[s] for s in states]\nsns.barplot(x=first_states, y=probs)\n\n\n<AxesSubplot:>\n\n\n\n\n\nThe state with the highest probability, \\(|01\\rangle\\), leads to the best of the four approximations, namely the one with binary representation \\(0.01\\), i.e. \\(\\theta\\approx 1/4\\). To get a better approximation, we take \\(n=3\\) which leads to the following probabilities:\n\n\nCode\nn = 3\npe = phase_est(u, n)\nin_state = Statevector.from_int(1, 2**(n+1)) \nout_state = in_state.evolve(pe)\nprob_dict = out_state.probabilities_dict()\nstates = list(prob_dict.keys())\nfirst_states = [s[:-1] for s in states]\nprobs = [prob_dict[s] for s in states]\nsns.barplot(x=first_states, y=probs)\n\n\n<AxesSubplot:>\n\n\n\n\n\nThe highest probability leads us to the binary representation \\(0.011\\), which gives the approximation \\(\\theta\\approx 3/8\\).\nThe following plot shows the (decimal) approximations that the phase estimation circuit produces for \\(2\\leq n\\leq 12\\). Each point corresponds to a possible state obtained by measuring the first \\(n\\) qubits in the output of the phase estimation circuit. The size of each point corresponds to the state’s probability, and only those states with probability greater than one percent are shown. We can see that the estimates obtained are indeed approaching the true value \\(\\theta=1/3\\).\n\n\nCode\ndef scatter_phase_estimates(u, input_int=0, qubit_size=12, rare=0.01): \n    '''\n    Produces a scatter plot of the phases estimates.\n    '''\n    u_size = u.num_qubits\n    num_qbits = []\n    probs = []\n    thetas = []\n    for n in range(2, qubit_size + 1):\n        pe = phase_est(u, n)\n        in_state = Statevector.from_int(input_int, 2**(n+u_size)) \n        out_state = in_state.evolve(pe)\n        out_state.draw('latex')\n        prob_dict = out_state.probabilities_dict()\n        states = list(prob_dict.keys())\n        num_qbits += [n for s in states if prob_dict[s] > rare]\n        probs += [prob_dict[s] for s in states if prob_dict[s] > rare]\n        thetas += [int(f'{s[:-u_size]}', base=2)/2**n for s in states if prob_dict[s] > rare]\n    graph = sns.scatterplot(x=num_qbits, y=thetas, size=probs)\n    graph.set_xlabel( \"n\" , size = 12 )\n    graph.set_ylabel( \"Estimate of theta (decimal)\" , size = 12 )\n    plt.show()\n\nscatter_phase_estimates(PhaseGate(2*pi/3), input_int=1)"
  },
  {
    "objectID": "posts/twindragon-binary/index.html#honest-phase-estimation-when-we-dont-already-know-the-eigenvalue",
    "href": "posts/twindragon-binary/index.html#honest-phase-estimation-when-we-dont-already-know-the-eigenvalue",
    "title": "Twindragons and a Binary System for Complex Numbers",
    "section": "Honest phase estimation: when we don’t already know the eigenvalue",
    "text": "Honest phase estimation: when we don’t already know the eigenvalue\nSo far we have looked at what the phase estimation circuit does to an input of the form \\(|0\\rangle^{\\otimes n}\\otimes|x\\rangle\\) where \\(|x\\rangle\\) is an eigenvector of \\(U\\). But hang on, if we know an eigenvector \\(|x\\rangle\\) for \\(U\\), we can just compute \\(U|x\\rangle\\) to determine the corresponding \\(\\theta\\). Phase estimation is only useful if it can determine (an estimate) for the phase without already knowing eigenvectors. Luckily, since \\(U\\) is unitary it is diagonalizable (by a Spectral Theorem). In other words, \\(U\\) admits a basis of eigenvectors. In particular, for any vector \\(|x\\rangle\\) we can write \\[\n|x\\rangle = \\alpha_1|x_1\\rangle+\\alpha_2|x_2\\rangle+\\cdots+\\alpha_m|x_m\\rangle\n\\tag{6}\\] where \\(|x_1\\rangle,\\ldots,|x_m\\rangle\\) are all eigenvectors of \\(U\\). Thus, if we run \\(|x\\rangle\\) through the phase estimation circuit will have the effect of running all the eigenvectors that appear in 6, weighted depending on the \\(\\alpha_i\\)’s. For example, let \\(U\\) denote the gate corresponding to the following (essentially randomly chosen) circuit:\n\n\nCode\nu = QuantumCircuit(2)\nu.h(0)\nu.ch(0,1)\nu.p(pi/6, 0)\nu.cp(pi/8, 1, 0)\nu.cy(0,1)\n\nu.draw(output='mpl', reverse_bits=True)\n\n\n\n\n\nSince \\(U\\) corresponds to a \\(4\\times 4\\) matrix, we know \\(U\\) has at most 4 distinct eigenvalues. Let \\(|x\\rangle=|00\\rangle\\) (which is not an eigenvector of \\(U\\)). The following shows the phase estimates obtained from the phase estimate circuit by inputting \\(|0\\rangle^{\\otimes n}\\otimes|x\\rangle=|0\\cdots0\\rangle\\) for various values of \\(n\\)\n\n\nCode\nu = u.to_gate()\nscatter_phase_estimates(u)\n\n\n\n\n\nNote that after some initial noise, the phase estimates stabilize at 4 different values. These are the four values of \\(\\theta\\) corresponding to the 4 distinct eigenvalues of \\(U\\). As this example illustrates, the process of quantum phase estimation really can be used to discover eigenvalues of a unitary matrix."
  },
  {
    "objectID": "posts/twindragon-binary/index.html#sec-intro",
    "href": "posts/twindragon-binary/index.html#sec-intro",
    "title": "Twindragons and a Binary System for Complex Numbers",
    "section": "Quantum phase estimation",
    "text": "Quantum phase estimation\n\n\nCode\nimport { chart } from \"d/3964d6d505b9f008\"\nchart\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe story of quantum phase estimation starts with a unitary matrix \\(U\\). Suppose \\(|x\\rangle\\) is an eigenvector of \\(U\\) so that \\(U|x\\rangle=\\lambda|x\\rangle\\) for some complex number \\(\\lambda\\). Since \\(U\\) is unitary, hence distance preserving, we know \\(|\\lambda|=1\\) so that \\(\\lambda=e^{2\\pi i\\theta}\\) for some \\(0\\leq\\theta<1\\). Quantum phase estimation uses a quantum circuit, depending on \\(U\\), to estimate \\(\\theta\\).\nThe quantum circuit for quantum phase estimation depends on the quantum Fourier transform (QFT). In a previous post I discussed QFT. In particular, I constructed a quantum circuit for QFT using qiskit. In this post I will reuse that code.\n\n\nCode\n1+2\n\n\n3"
  },
  {
    "objectID": "posts/twindragon-binary/index.html#a-binary-system-for-complex-numbers",
    "href": "posts/twindragon-binary/index.html#a-binary-system-for-complex-numbers",
    "title": "Twindragons and a Binary System for Complex Numbers",
    "section": "A Binary System for Complex Numbers",
    "text": "A Binary System for Complex Numbers\n\nFirst Calculations\nLet’s look at the same binary string 1100 from above, but this time using the new base of \\(i-1\\). In the twindragon binary system \\(\\textcolor{#e95420}{1100}\\) represents \\[\\textcolor{#e95420}{1}(i-1)^3+\\textcolor{#e95420}{1}(i-1)^2+\\textcolor{#e95420}{0}(i-1)^1+\\textcolor{#e95420}{0}(i-1)^0. \\tag{1}\\] For another example, in twindragon binary \\(1111001\\) represents \\[(i-1)^6+(i-1)^5+(i-1)^4+(i-1)^3+(i-1)^0. \\tag{2}\\] To simplify these expressions, it will be useful to know powers of \\(i-1\\). Here are the first several: \\[\\begin{array}{|c|c|}\n\\hline\nn & (i-1)^n \\\\\n\\hline\n0 & 1 \\\\\n1 & i-1 \\\\\n2 & -2i \\\\\n3 & 2+2i \\\\\n4 & -4 \\\\\n5 & 4-4i \\\\\n6 & 8i \\\\\n7 & -8-8i \\\\\n8 & 16 \\\\\n\\hline\n\\end{array}\\] Using these powers we can simplify (1) to see that \\(\\textcolor{#e95420}{1100}\\) is the twindragon binary representation of the integer 2. Simplifying (2) shows us \\(1111001\\) is the twindragon binary representation of the complex number \\(3+6i\\).\nNotice that sums of powers of \\(i-1\\) will always result in a Guassian integer. In fact, we will soon see that each Guassian integer arises (uniquely) in this way.\n\n\n\nSimilar calculations can be used to verify the following twindragon representations: \\[\\begin{array}{|c|c|}\n\\hline\n\\text{twindragon} & \\text{complex} \\\\\n\\text{binary} & \\text{number} \\\\\n\\hline\n0 & 0 \\\\\n1 & 1 \\\\\n11 & i \\\\\n111 & -i \\\\\n11101 & -1 \\\\\n\\hline\n\\end{array} \\tag{3}\\]"
  },
  {
    "objectID": "posts/twindragon-binary/index.html#twindragons",
    "href": "posts/twindragon-binary/index.html#twindragons",
    "title": "Twindragons and a Binary System for Complex Numbers",
    "section": "Twindragons",
    "text": "Twindragons\n\n\nCode\nimport { chart } from \"d/3964d6d505b9f008\"\nchart"
  },
  {
    "objectID": "posts/twindragon-binary/index.html#section",
    "href": "posts/twindragon-binary/index.html#section",
    "title": "Twindragons and a Binary System for Complex Numbers",
    "section": "",
    "text": "Animation"
  },
  {
    "objectID": "posts/twindragon-binary/index.html#section-1",
    "href": "posts/twindragon-binary/index.html#section-1",
    "title": "Twindragons and a Binary System for Complex Numbers",
    "section": "",
    "text": "Implicit\nAnimation"
  },
  {
    "objectID": "posts/twindragon-binary/index.html#references",
    "href": "posts/twindragon-binary/index.html#references",
    "title": "Twindragons and a Binary System for Complex Numbers",
    "section": "References",
    "text": "References\nI first learned about the twindragon binary number system and the corresponding fractiling of the complex plane from G. Edgar’s book Measure, Topology, and Fractal Geometry. The first appearance the twindragon binary number system is in W. Penny’s A “Binary” System for Complex Numbers. I believe the first connection between the number system and the twindragon fractal is due to D. Knuth: Number representations and dragon curves."
  },
  {
    "objectID": "posts/twindragon-binary/index.html#the-twindragon-binary-system-for-complex-numbers",
    "href": "posts/twindragon-binary/index.html#the-twindragon-binary-system-for-complex-numbers",
    "title": "Twindragons and a Binary System for Complex Numbers",
    "section": "The twindragon binary system for complex numbers",
    "text": "The twindragon binary system for complex numbers\nThis post is concerned with a (non-standard) binary number system whose base is the complex number \\(i-1\\). We’ll see the beautiful fractal known as the twindragon showing up when we visualize this number system in the complex plane, so we call this number system the twindragon binary system.\n\nFirst calculations\nLet’s look at the same binary string 1100 from above, but this time using the new base of \\(i-1\\). In the twindragon binary system \\(\\textcolor{#e95420}{1100}\\) represents \\[\\textcolor{#e95420}{1}(i-1)^3+\\textcolor{#e95420}{1}(i-1)^2+\\textcolor{#e95420}{0}(i-1)^1+\\textcolor{#e95420}{0}(i-1)^0. \\tag{1}\\] For another example, in twindragon binary \\(1111001\\) represents \\[(i-1)^6+(i-1)^5+(i-1)^4+(i-1)^3+(i-1)^0. \\tag{2}\\] To simplify these expressions, it will be useful to know powers of \\(i-1\\). Here are the first several: \\[\\begin{array}{|c|c|}\n\\hline\nn & (i-1)^n \\\\\n\\hline\n0 & 1 \\\\\n1 & i-1 \\\\\n2 & -2i \\\\\n3 & 2+2i \\\\\n4 & -4 \\\\\n5 & 4-4i \\\\\n6 & 8i \\\\\n7 & -8-8i \\\\\n8 & 16 \\\\\n\\hline\n\\end{array}\\] Using these powers we can simplify (1) to see that \\(\\textcolor{#e95420}{1100}\\) is the twindragon binary representation of the integer 2. Simplifying (2) shows us \\(1111001\\) is the twindragon binary representation of the complex number \\(3+6i\\).\nNotice that sums of powers of \\(i-1\\) will always result in a Guassian integer. In fact, we will soon see that each Guassian integer arises (uniquely) in this way.\n\n\nTwindragon representations of units\nTowards showing all Guassian integers have a twindragon binary representation, we start with the smallest. Of course, the twindragon representation of 0 is merely 0. The next smallest Gaussian integers are the four units: \\(\\pm 1, \\pm i\\). The following table shows the twindragon representations of those units. One can verify the values in the table using the methods above. \\[\\begin{array}{|c|c|}\n\\hline\n\\text{Gaussian} & \\text{twindragon}  \\\\\n\\text{integer} & \\text{binary} \\\\\n\\hline\n1 & 1 \\\\\ni & 11 \\\\\n-i & 111 \\\\\n-1 & 11101 \\\\\n\\hline\n\\end{array} \\tag{3}\\] Every other Guassian integer is the sum of unit Guassian integers. Since we know how the twindragon represents all the units, to see how to represent an arbitrary Guassian integer it suffices to provide an algorithm for twindragon addition."
  },
  {
    "objectID": "posts/twindragon-binary/index.html#twindragon-addition-algorithm",
    "href": "posts/twindragon-binary/index.html#twindragon-addition-algorithm",
    "title": "Twindragons and a Binary System for Complex Numbers",
    "section": "Twindragon addition algorithm",
    "text": "Twindragon addition algorithm\nThe addition algorithm for the twindragon binary system is similar to the one using standard binary: stack the binary strings atop one another lining up the rightmost bit, then add bits one by one from right to left with the appropriate carry procedure. There are, however, two key rules for twindragon addition that make the algorithm quite different from the standard one.\n\nA twindragon carry rule\nThe first key difference is the manner in which one “carries” bits. In the standard algorithm, one needs to “carry a 1” whenever the adding two 1’s. This corresponds to the fact that the standard binary representation of 2 (i.e. 1+1) is 10. As we’ve seen above, the twindragon binary representation of the integer 2 is 1100. Thus we have the following twindragon carry rule:\n\\[\\begin{array}{cr}\n  & 1\\\\\n+ & 1\\\\\n\\hline\n& 1100\n\\end{array} \\tag{4}\\]\nThis means that when the twindragon adds two 1’s it carries both 1’s to the positions according to the carry rule (4). For example, consider the following sum: \\[\\begin{array}{cr}\n  & 111001\\\\\n+ & 101010\\\\\n\\hline\n\\end{array}\\] Starting from the right, the first three columns of bits are easily handled, leaving us at the following point: \\[\\begin{array}{cr}\n  & 11\\textcolor{#e95420}{1}\\textcolor{#aea79f}{001}\\\\\n+ & 10\\textcolor{#e95420}{1}\\textcolor{#aea79f}{010}\\\\\n\\hline\n  & 011\n\\end{array}\\] Now, we carry the next two 1’s according to the carry rule (4) leaving us with the following: \\[\\begin{array}{cr}\n  & \\textcolor{#e95420}{1100}\\phantom{000}\\\\\n  & 11\\textcolor{#aea79f}{\\hspace{-5.75pt}\\not{1}001}\\\\\n+ & 10\\textcolor{#aea79f}{\\hspace{-5.75pt}\\not{1}010}\\\\\n\\hline\n  & 0011\n\\end{array}\\] The next column of bits is easily handled, leaving us in a position where we will have to carry two 1’s again: \\[\\begin{array}{cr}\n  & 1\\textcolor{#e95420}{1}\\textcolor{#aea79f}{00}\\phantom{000}\\\\\n  &  \\textcolor{#e95420}{1}\\textcolor{#aea79f}{11001}\\\\\n+ &   1\\textcolor{#aea79f}{01010}\\\\\n\\hline\n  & 10011\n\\end{array}\\] Again, we carry according to the carry rule (4) leaving us with \\[\\begin{array}{cr}\n  & \\textcolor{#e95420}{1100}\\phantom{00000} \\\\\n  & 1\\textcolor{#aea79f}{\\hspace{-5.75pt}\\not{1}00}\\phantom{000}\\\\\n  &  \\textcolor{#aea79f}{\\hspace{-5.75pt}\\not{1}11001}\\\\\n+ &   \\textcolor{#aea79f}{101010}\\\\\n\\hline\n  & 110011\n\\end{array}\\] The last three columns involve no carries, which gives the final result: \\[\\begin{array}{cr}\n  & \\textcolor{#aea79f}{1100}\\phantom{00000} \\\\\n  & \\textcolor{#aea79f}{1100}\\phantom{000}\\\\\n  &  \\textcolor{#aea79f}{111001}\\\\\n+ &   \\textcolor{#aea79f}{101010}\\\\\n\\hline\n  & 111110011\n\\end{array}\\]\n\n\nA twindragon cancel rule\nRecall from (3) that the twindragon representations of \\(i\\) and \\(-i\\) are 11 and 111, respectively. As a consequence, we get the following twindragon cancel rule: \\[\\begin{array}{cr}\n  &  11\\\\\n+ & 111\\\\\n\\hline\n  &   0\n\\end{array} \\tag{5}\\] Observe that the sum in (5) cannot be computed in a finite number of steps using just the carry rule (4). Indeed, applying the carry rule to the rightmost bits in the sum above gives the following \\[\n\\begin{array}{cr}\n  &  1\\textcolor{#e95420}{1}\\\\\n+ & 11\\textcolor{#e95420}{1}\\\\\n\\hline\n\\end{array}\n\\quad\\leadsto\\quad\n\\begin{array}{cr}\n  & \\textcolor{#e95420}{1100}\\\\\n  &  1\\textcolor{#aea79f}{\\hspace{-5.75pt}\\not{1}}\\\\\n+ & 11\\textcolor{#aea79f}{\\hspace{-5.75pt}\\not{1}}\\\\\n\\hline\n  &   0\n\\end{array}\n\\] If we ignore the 0’s and drop the top two 1’s down a row or two, then we are left with the following: \\[\\begin{array}{cr}\n  &  11\\textcolor{#aea79f}{\\hspace{-5.75pt}\\not{1}}\\\\\n+ & 111\\textcolor{#aea79f}{\\hspace{-5.75pt}\\not{1}}\\\\\n\\hline\n  &   0\n\\end{array}\\] Computing the sum of the remaining columns of bits is the same sum we started with. Thus, if we continue then we will get a never-ending sting of 0’s as a result (which could be considered correct), but the algorithm never terminates.\nIt turns out that the combination of the carry rule (4) and cancel rule (5) suffice to compute the sum of any two binary strings in a finite number of steps. The most efficient way is to apply the cancel rule whenever possible. Here’s an example: \\[\\begin{array}{cr}\n  & 111011111\\\\\n+ &  10110110\\\\\n\\hline\n\\end{array}\\] To start, note that we can use the cancel rule (5) as follows: \\[\n\\begin{array}{cr}\n  & 11101\\textcolor{#e95420}{111}1\\\\\n+ &  10110\\textcolor{#e95420}{11}0\\\\\n\\hline\n\\end{array}\n\\quad\\leadsto\\quad\n\\begin{array}{cr}\n  & 11101\\textcolor{#e95420}{000}1\\\\\n+ &  10110\\textcolor{#e95420}{00}0\\\\\n\\hline\n\\end{array}\n\\] Now, we proceed from right to left, and nothing interesting happens (thanks to all the new 0’s) until we reach the following point: \\[\\begin{array}{cr}\n  & 11101\\textcolor{#aea79f}{0001}\\\\\n+ &  1011\\textcolor{#aea79f}{0000}\\\\\n\\hline\n  & 0001\n\\end{array}\\] Next, we apply the carry rule (4): \\[\n\\begin{array}{cr}\n\\\\\n  & 1110\\textcolor{#e95420}{1}\\textcolor{#aea79f}{0001}\\\\\n+ &  101\\textcolor{#e95420}{1}\\textcolor{#aea79f}{0000}\\\\\n\\hline\n  & 0001\n\\end{array}\n\\quad\\leadsto\\quad\n\\begin{array}{cr}\n  &  \\textcolor{#e95420}{1100}\\phantom{0000}\\\\\n  & 1110\\textcolor{#aea79f}{\\hspace{-5.75pt}\\not{1}0001}\\\\\n+ &  101\\textcolor{#aea79f}{\\hspace{-5.75pt}\\not{1}0000}\\\\\n\\hline\n  & 00001\n\\end{array}\n\\] Now, we can once again apply the cancel rule (5): \\[\n\\begin{array}{cr}\n  &  \\textcolor{#e95420}{11}0\\textcolor{#aea79f}{0}\\phantom{0000}\\\\\n  & \\textcolor{#e95420}{111}0\\textcolor{#aea79f}{10001}\\\\\n+ &  101\\textcolor{#aea79f}{10000}\\\\\n\\hline\n  & 00001\n\\end{array}\n\\quad\\leadsto\\quad\n\\begin{array}{cr}\n  &  \\textcolor{#e95420}{00}0\\textcolor{#aea79f}{0}\\phantom{0000}\\\\\n  & \\textcolor{#e95420}{000}0\\textcolor{#aea79f}{10001}\\\\\n+ &  101\\textcolor{#aea79f}{10000}\\\\\n\\hline\n  & 00001\n\\end{array}\n\\] The rest of the calculation is straightforward, giving the following result: \\[\\begin{array}{cr}\n  &  \\textcolor{#aea79f}{0000}\\phantom{0000}\\\\\n  &  \\textcolor{#aea79f}{000010001}\\\\\n+ &   \\textcolor{#aea79f}{10110000}\\\\\n\\hline\n  & 10100001\n\\end{array}\\]\n\n\nThe addition algorithm\nAs the example above illustrates, the following algorithm can be used to compute the sum of any finite collection of binary strings in the twindragon binary system:\n\nStack the binary strings atop one another in the usual way.\nStart with the rightmost column of bits.\nWhile there are still columns of nonzero bits to add:\n\nApply the cancel rule as many times as possible.\nWhile there are at least two 1’s in the current column:\n\nApply the carry rule.\nApply the cancel rule if possible.\n\nAdd the remaining bits in the column (at most one of which is a 1).\nMove one column to the left\n\n\nThe proof that the algorithm always terminates can be found below.\n\n\nProof\n\nIt suffices to prove that the twindragon sum of two binary strings terminates. By adding extra 0’s to the left of one string if necessary, we may assume both strings have the same length. Thus, the sum has the following form: \\[\\begin{array}{cccccc}\n      &  a_n & \\cdots & a_2 & a_1 & a_0\\\\\n    + &  b_n & \\cdots & b_2 & b_1 & a_0\\\\\n    \\hline\n    \\end{array}\\] We proceed by inducting on the number of 1’s that need to be added. If at any point we can apply the cancel rule, the number of 1’s decreases by five, and we are done by induction. Thus, we may assume it is never possible to apply the cancel rule. Starting on the right, add all the columns that contain only 0’s bringing us to a point looking like the following: \\[\\begin{array}{cccccc}\n      &  a_n & \\cdots & a_{j+1} & a_j & \\textcolor{#aea79f}{0\\cdots0}\\\\\n    + &  b_n & \\cdots & b_{j+1} & b_j & \\textcolor{#aea79f}{0\\cdots0}\\\\\n    \\hline\n      &&&&& 0\\cdots0\n    \\end{array}\\] Where at least one of \\(a_j\\) or \\(b_j\\) is 1. If the other is 0, then we add that column without a carry, the remaining columns will have one fewer 1, and we are done by induction. Thus we only need to consider the case where both \\(a_j\\) and \\(b_j\\) are 1, and we carry: \\[\\begin{array}{ccccccc}\n      &  a_n & \\cdots & a_{j+3} & a_{j+2} & a_{j+1} & \\textcolor{#e95420}{1}~\\textcolor{#aea79f}{0\\cdots0}\\\\\n    + &  b_n & \\cdots & b_{j+3} & b_{j+2} & b_{j+1} & \\textcolor{#e95420}{1}~\\textcolor{#aea79f}{0\\cdots0}\\\\\n    \\hline\n      &&&&&& \\phantom{1~}0\\cdots0\n    \\end{array}\\] \\[\\begin{array}{ccccccr}\n     &&&\\textcolor{#e95420}{1}&\\textcolor{#e95420}{1}&\\textcolor{#e95420}{0}& \\textcolor{#e95420}{0}~\\phantom{0\\cdots0} \\\\\n      &  a_n & \\cdots & a_{j+3} & a_{j+2} & a_{j+1} &  \\textcolor{#aea79f}{\\hspace{-5.75pt}\\not{1}~0\\cdots0}\\\\\n    + &  b_n & \\cdots & b_{j+3} & b_{j+2} & b_{j+1} &  \\textcolor{#aea79f}{\\hspace{-5.75pt}\\not{1}~0\\cdots0}\\\\\n    \\hline\n      &&&&&& 0~0\\cdots0\n    \\end{array}\\] Now, we may assume \\(a_{j+1}\\) and \\(b_{j+1}\\) are either both 0’s or both 1’s (else we can add that column, and we’re done by induction). In either case, adding the \\((j+1)^{\\text{st}}\\) column will not contribute any more 1’s to the \\((j+2)^{\\text{nd}}\\) column. Thus we may assume one of \\(a_{j+2}\\) and \\(b_{j+2}\\) is 0 and the other is 1 (else adding the \\((j+2)^{\\text{nd}}\\) column will result in a 1, and the remaining columns will have one fewer 1, and we’re done by induction). Without loss of generality, we may assume \\(a_{j+2}=1\\) and \\(b_{j+2}=0\\), so the sum looks like \\[\\begin{array}{ccccccr}\n     &&& 1 & 1 & 0 & \\textcolor{#aea79f}{0}~\\phantom{0\\cdots0} \\\\\n      &  a_n & \\cdots & a_{j+3} & 1 & a_{j+1} &  \\textcolor{#aea79f}{\\hspace{-5.75pt}\\not{1}~0\\cdots0}\\\\\n    + &  b_n & \\cdots & b_{j+3} & 0 & b_{j+1} &  \\textcolor{#aea79f}{\\hspace{-5.75pt}\\not{1}~0\\cdots0}\\\\\n    \\hline\n      &&&&&& 0~0\\cdots0\n    \\end{array}\\] Now, if \\(a_{j+1}\\) and \\(b_{j+1}\\) are both 1’s, then we can apply the cancel rule (and we’re done by induction), so it suffices to consider the case where they are both 0. Then we add the \\((j+1)^{\\text{st}}\\) column and we perform a carry on the \\((j+2)^{\\text{nd}}\\) column: \\[\\begin{array}{ccccccr}\n     &&&&& 1 & \\textcolor{#e95420}{1} ~ \\textcolor{#aea79f}{0}~\\textcolor{#aea79f}{0}~\\phantom{0\\cdots0} \\\\\n      &  a_n & \\cdots & a_{j+5} & a_{j+4} & a_{j+3} & \\textcolor{#e95420}{1} ~  \\textcolor{#aea79f}{0~\\hspace{-5.75pt}\\not{1}~0\\cdots0}\\\\\n    + &  b_n & \\cdots & b_{j+5} & b_{j+4} & b_{j+3} & 0 ~  \\textcolor{#aea79f}{0~\\hspace{-5.75pt}\\not{1}~0\\cdots0}\\\\\n    \\hline\n      &&&&&& 0~0~0\\cdots0\n    \\end{array}\\]\n\\[\\begin{array}{ccccccr}\n     & & & \\textcolor{#e95420}{1} & \\textcolor{#e95420}{1} & \\textcolor{#e95420}{0} & \\textcolor{#e95420}{0}\\phantom{~0~0~0\\cdots0}\\\\\n     &&&&& 1 & \\textcolor{#aea79f}{\\hspace{-5.75pt}\\not{1}~0}~\\textcolor{#aea79f}{0}~\\phantom{0\\cdots0} \\\\\n      &  a_n & \\cdots & a_{j+5} & a_{j+4} & a_{j+3} &   \\textcolor{#aea79f}{\\hspace{-5.75pt}\\not{1}~0~\\hspace{-5.75pt}\\not{1}~0\\cdots0}\\\\\n    + &  b_n & \\cdots & b_{j+5} & b_{j+4} & b_{j+3} &   \\textcolor{#aea79f}{0~0~\\hspace{-5.75pt}\\not{1}~0\\cdots0}\\\\\n    \\hline\n      &&&&&& 0~0~0~0\\cdots0\n    \\end{array}\\] Arguing as before, if both \\(a_{j+3}\\) and \\(b_{j+3}\\) are 0, then adding the \\((j+3)^{\\text{rd}}\\) column will leave us with one fewer 1 (and we’d be done by induction). Thus, we may assume there are two 1’s in the \\((j+3)^{\\text{rd}}\\) column. Since a carry from the \\((j+3)^{\\text{rd}}\\) column will not contribute a 1 to the \\((j+4)^{\\text{th}}\\) column, similar reasoning allows us to assume one of \\(a_{j+4}\\) and \\(b_{j+4}\\) is a 1. But now we are in a situation where the \\((j+3)^{\\text{rd}}\\) and \\((j+4)^{\\text{th}}\\) columns each have two 1’s, and the \\((j+5)^{\\text{th}}\\) column has a 1. Then we can apply the cancel rule, and we are done by induction."
  },
  {
    "objectID": "posts/twindragon-binary/index.html#proofs",
    "href": "posts/twindragon-binary/index.html#proofs",
    "title": "Twindragons and a Binary System for Complex Numbers",
    "section": "Proofs",
    "text": "Proofs\n\nProof that the addition algorithm terminates\n\n\nProof twindragon representations of Gaussian integers are unique"
  },
  {
    "objectID": "posts/twindragon-binary/index.html#twindragon-representations-of-all-gaussian-integers",
    "href": "posts/twindragon-binary/index.html#twindragon-representations-of-all-gaussian-integers",
    "title": "Twindragons and a Binary System for Complex Numbers",
    "section": "Twindragon representations of all Gaussian integers",
    "text": "Twindragon representations of all Gaussian integers\nTo see that every Gaussian integer has a twindragon representation, notice that every Gaussian integer can be written as a sum of the units \\(\\pm1\\) and \\(\\pm i\\). Since we know how to represent those units in twindragon binary (see (3)) we can find the desired twindragon representation using the addition algorithm. For example, to find the twindragon representation of \\(-3+5i\\) we add three copies of the representation of \\(-1\\) (11101) to five copies of the representation of \\(i\\) (11). For those who are interested, the details of finding the representation of \\(-3+5i\\) can be found below.\n\n\nDetails\n\nLet’s see what happens: \\[\\begin{array}{cr}\n      & 11101\\\\\n      & 11101\\\\\n      & 11101\\\\\n      &    11\\\\\n      &    11\\\\\n      &    11\\\\\n      &    11\\\\\n    + &    11\\\\\n    \\hline\n    \\end{array}\\] First, let’s shift the bits down in the left three columns for convenience: \\[\\begin{array}{cr}\n      &     1\\\\\n      &     1\\\\\n      &     1\\\\\n      &    11\\\\\n      &    11\\\\\n      & 11111\\\\\n      & 11111\\\\\n    + & 11111\\\\\n    \\hline\n    \\end{array}\\] Now, we can apply a the cancel rule (5) a couple times: \\[\n    \\begin{array}{cr}\n      &     1\\\\\n      &     1\\\\\n      &     1\\\\\n      &    11\\\\\n      &   \\textcolor{#e95420}{ 11}\\\\\n      & 11\\textcolor{#e95420}{111}\\\\\n      & 1\\textcolor{blue}{11}11\\\\\n    + & \\textcolor{blue}{111}11\\\\\n    \\hline\n    \\end{array}\n    \\quad\\leadsto\\quad\n    \\begin{array}{cr}\n      &     1\\\\\n      &     1\\\\\n      &     1\\\\\n      &    11\\\\\n      &   \\textcolor{#e95420}{ 00}\\\\\n      & 11\\textcolor{#e95420}{000}\\\\\n      & 1\\textcolor{blue}{00}11\\\\\n    + & \\textcolor{blue}{000}11\\\\\n    \\hline\n    \\end{array}\n    \\] After shifting the bits down again (for convenience) we have: \\[\\begin{array}{cr}\n      &     1\\\\\n      &     1\\\\\n      &     1\\\\\n      &    11\\\\\n      & 10011\\\\\n    + & 11011\\\\\n    \\hline\n    \\end{array}\\] Next, we apply the carry rule (4) one time to the rightmost column to get \\[\n    \\begin{array}{cr}\n      &     \\textcolor{#e95420}{1}\\\\\n      &     \\textcolor{#e95420}{1}\\\\\n      &     1\\\\\n      &    11\\\\\n      & 10011\\\\\n    + & 11011\\\\\n    \\hline\n    \\end{array}\n    \\quad\\leadsto\\quad\n    \\begin{array}{cr}\n      & \\textcolor{#e95420}{1100}\\\\\n      &     \\textcolor{#aea79f}{\\hspace{-5.75pt}\\not{1}}\\\\\n      &     \\textcolor{#aea79f}{\\hspace{-5.75pt}\\not{1}}\\\\\n      &     1\\\\\n      &    11\\\\\n      & 10011\\\\\n    + & 11011\\\\\n    \\hline\n    \\end{array}\\] Dropping bits (and removing crossed out ones) gives the following, where we apply the cancel rule (5): \\[\n    \\begin{array}{cr}\n      &     1\\\\\n      &    \\textcolor{#e95420}{11}\\\\\n      & 11\\textcolor{#e95420}{111}\\\\\n    + & 11011\\\\\n    \\hline\n    \\end{array}\n    \\quad\\leadsto\\quad\n    \\begin{array}{cr}\n      &     1\\\\\n      &    \\textcolor{#e95420}{00}\\\\\n      & 11\\textcolor{#e95420}{000}\\\\\n    + & 11011\\\\\n    \\hline\n    \\end{array}\n    \\] Let’s drop the bits again, and then we apply the carry rule to the right column: \\[\n    \\begin{array}{cr}\n    \\\\\n      & 1100\\textcolor{#e95420}{1}\\\\\n    + & 1101\\textcolor{#e95420}{1}\\\\\n    \\hline\n    \\end{array}\n    \\quad\\leadsto\\quad\n    \\begin{array}{cr}\n      & \\textcolor{#e95420}{1100}\\\\\n      & 1100\\textcolor{#aea79f}{\\hspace{-5.75pt}\\not{1}}\\\\\n    + & 1101\\textcolor{#aea79f}{\\hspace{-5.75pt}\\not{1}}\\\\\n    \\hline\n    \\end{array}\n    \\] Now we sum the three rightmost columns to get: \\[\n    \\begin{array}{cr}\n      & 1\\textcolor{#aea79f}{100}\\\\\n      & 11\\textcolor{#aea79f}{00\\hspace{-5.75pt}\\not{1}}\\\\\n    + & 11\\textcolor{#aea79f}{01\\hspace{-5.75pt}\\not{1}}\\\\\n    \\hline\n      & 110\n    \\end{array}\n    \\] The next column requires a carry: \\[\n    \\begin{array}{cr}\n      & \\textcolor{#e95420}{1}\\textcolor{#aea79f}{100}\\\\\n      & 1\\textcolor{#e95420}{1}\\textcolor{#aea79f}{00\\hspace{-5.75pt}\\not{1}}\\\\\n    + & 11\\textcolor{#aea79f}{01\\hspace{-5.75pt}\\not{1}}\\\\\n    \\hline\n      & 110\n    \\end{array}\n    \\quad\\leadsto\\quad\n    \\begin{array}{cr}\n      & \\textcolor{#e95420}{1100}\\phantom{000}\\\\\n      & \\textcolor{#aea79f}{\\hspace{-5.75pt}\\not{1}100}\\\\\n      & 1\\textcolor{#aea79f}{\\hspace{-5.75pt}\\not{1}00\\hspace{-5.75pt}\\not{1}}\\\\\n    + & 11\\textcolor{#aea79f}{01\\hspace{-5.75pt}\\not{1}}\\\\\n    \\hline\n      & 110\n    \\end{array}\n    \\] We now add the current column of bits, and then drop the other bits for convenience: \\[\n    \\begin{array}{cr}\n      & \\textcolor{#aea79f}{\\hspace{-5.75pt}\\not{1}100}\\\\\n      & 1\\textcolor{#aea79f}{\\hspace{-5.75pt}\\not{1}00\\hspace{-5.75pt}\\not{1}}\\\\\n    + & 111\\textcolor{#aea79f}{101\\hspace{-5.75pt}\\not{1}}\\\\\n    \\hline\n      & 1110\n    \\end{array}\n    \\] The next column uses a carry rule: \\[\n    \\begin{array}{cr}\n      & \\textcolor{#aea79f}{\\hspace{-5.75pt}\\not{1}100}\\\\\n      & \\textcolor{#e95420}{1}\\textcolor{#aea79f}{\\hspace{-5.75pt}\\not{1}00\\hspace{-5.75pt}\\not{1}}\\\\\n    + & 11\\textcolor{#e95420}{1}\\textcolor{#aea79f}{101\\hspace{-5.75pt}\\not{1}}\\\\\n    \\hline\n      & 1110\n    \\end{array}\n    \\quad\\leadsto\\quad\n    \\begin{array}{cr}\n      & \\textcolor{#e95420}{1100}\\textcolor{#aea79f}{\\hspace{-5.75pt}\\not{1}100}\\\\\n      & \\textcolor{#aea79f}{\\hspace{-5.75pt}\\not{1}\\hspace{-5.75pt}\\not{1}00\\hspace{-5.75pt}\\not{1}}\\\\\n    + & 11\\textcolor{#aea79f}{\\hspace{-5.75pt}\\not{1}101\\hspace{-5.75pt}\\not{1}}\\\\\n    \\hline\n      & 1110\n    \\end{array}\n    \\] Now we can sum the current column, and the next one. After dropping some bits we are left with \\[\n    \\begin{array}{cr}\n      & 1\\textcolor{#aea79f}{0\\hspace{-5.75pt}\\not{1}\\hspace{-5.75pt}\\not{1}00\\hspace{-5.75pt}\\not{1}}\\\\\n    + & 11\\textcolor{#aea79f}{1\\hspace{-5.75pt}\\not{1}101\\hspace{-5.75pt}\\not{1}}\\\\\n    \\hline\n      & 101110\n    \\end{array}\n    \\] One last carry: \\[\n    \\begin{array}{cr}\n    \\\\\n      & \\textcolor{#e95420}{1}\\textcolor{#aea79f}{0\\hspace{-5.75pt}\\not{1}\\hspace{-5.75pt}\\not{1}00\\hspace{-5.75pt}\\not{1}}\\\\\n    + & 1\\textcolor{#e95420}{1}\\textcolor{#aea79f}{1\\hspace{-5.75pt}\\not{1}101\\hspace{-5.75pt}\\not{1}}\\\\\n    \\hline\n      & 101110\n    \\end{array}\n    \\quad\\leadsto\\quad\n    \\begin{array}{cr}\n     & \\textcolor{#e95420}{1100}\\phantom{000000}\\\\\n      & \\textcolor{#aea79f}{\\hspace{-5.75pt}\\not{1}0\\hspace{-5.75pt}\\not{1}\\hspace{-5.75pt}\\not{1}00\\hspace{-5.75pt}\\not{1}}\\\\\n    + & 1\\textcolor{#aea79f}{\\hspace{-5.75pt}\\not{1}1\\hspace{-5.75pt}\\not{1}101\\hspace{-5.75pt}\\not{1}}\\\\\n    \\hline\n      & 101110\n    \\end{array}\n    \\] The rest is straightforward: \\[\n    \\begin{array}{cr}\n     & \\textcolor{#aea79f}{1100}\\phantom{000000} \\\\\n      & \\textcolor{#aea79f}{\\hspace{-5.75pt}\\not{1}0\\hspace{-5.75pt}\\not{1}\\hspace{-5.75pt}\\not{1}00\\hspace{-5.75pt}\\not{1}} \\\\\n    + & \\textcolor{#aea79f}{1\\hspace{-5.75pt}\\not{1}1\\hspace{-5.75pt}\\not{1}101\\hspace{-5.75pt}\\not{1}}\\\\\n    \\hline\n      & 1110101110\n    \\end{array}\n    \\] Thus, we have found that the twindragon representation of \\(-3+5i\\) is \\(1110101110\\)."
  },
  {
    "objectID": "posts/twindragon-binary/index.html#twindragons-in-the-complex-plane",
    "href": "posts/twindragon-binary/index.html#twindragons-in-the-complex-plane",
    "title": "Twindragons and a Binary System for Complex Numbers",
    "section": "Twindragons in the complex plane",
    "text": "Twindragons in the complex plane\nWe have seen that every Gaussian integer has a twindragon representation. In fact, these representations are unique (it’s a fun exercise to prove this). Thus, we have a way to label every point in the lattice of Gaussian integers in the complex plane with a binary string.\nIn the following plot, a unit square is drawn around each of the \\(2^{15}\\) Gaussian integers whose twindragon representations use 15 or fewer bits. The color of the square is determined by the length of the binary string: the more bits, the darker the square. For example, 0 is the lightest color; you can find it in the middle of the picture (you can zoom in). The next lightest square is 1, then 10 and 11 are just a little darker, and so on. The darkest squares are the \\(2^{14}\\) Gaussian integers whose twindragon representations are 15 bits long.\nAs the color darkens, the corresponding regions in the plane are approaching the beautiful Davis-Knuth dragon, also known as the twindragon, hence the name of the binary system.\n\n\nCode\nimport { chart } from \"d/3964d6d505b9f008\"\nchart\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nA twindragon fractiling\nWe can extend the twindragon system from Gaussian integers to all complex numbers by adding fractional parts. For example, we write \\(101.01\\) for the complex number \\[(i-1)^2 + (i-1)^0 + (i-1)^{-2} = 1-1.5i\\] We call \\(101\\) and \\(0.01\\) the whole and fraction parts of \\(101.01\\), respectively. Notice that representations with nonzero fraction parts can indeed have non-integer real or imaginary parts. One can show that every complex number can be represented in twindragon binary if we allow (possibly infinitely long) fraction parts. It should be noted that we no longer get uniqueness of representations after adding fraction parts.\nIf we plot all the complex numbers whose twindragon representation have the same fixed whole part, the result is a twindragon. Moreover, all these twindragons (one for each Gaussian integer) tile the complex plane. Such a tiling by fractals is sometimes called a fractiling. We can see this twindragon fractiling in the following plot. There we plot each complex number whose twindragon representation has whole part with at most 3 bits, and fraction with at most 13 bits. The color of these \\(2^{16}\\) points corresponds to the whole part as follows:\n\\[\\begin{array}{|c|cccccccc|}\n\\hline\n\\text{whole part} & 0 & 1 & 10 & 11 & 100 & 101 & 110 & 111\\\\\n\\hline\n\\text{color} & \\textcolor{#ff6961}{\\bullet} & \\textcolor{#ffb480}{\\bullet} & \\textcolor{#f8f38d}{\\bullet} & \\textcolor{#42d6a4}{\\bullet} & \\textcolor{#08cad1}{\\bullet} & \\textcolor{#59adf6}{\\bullet} & \\textcolor{#9d94ff}{\\bullet} & \\textcolor{#c780e8}{\\bullet} \\\\\n\\hline\n\\end{array}\\]\n\n\nCode\nimport { fractionChart } from \"d/526bb5e596bf883a\"\nfractionChart\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nA twindragon of twindragons\nIn the first plot, we used unit squares to represent each Gaussian integer, and those squares nicely tiled the complex plane. However, those squares are not the best picture of the Gaussian integers from the viewpoint of the twindragon. Indeed, the second plot shows that we should really replace those unit squares with “unit twindragons”, i.e. the collection of all points in the complex plane that share the same whole part. In the final plot below, we plot all complex numbers whose twindragon representation has whole part with at most 11 bits, and fraction part with at most 6 bits. The points are colored according to the length of their whole part (the longer the whole part the darker the point).\n\n\nCode\nimport { twindragonChart } from \"d/60ea50d21dd08209\"\ntwindragonChart"
  }
]