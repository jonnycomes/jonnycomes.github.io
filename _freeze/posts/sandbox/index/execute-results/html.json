{
  "hash": "6cfb4c760f703aad31f399342decb26d",
  "result": {
    "markdown": "---\ntitle: Sandbox\nauthor: Jonny Comes\ndate: '2022-12-02'\ncategories:\n  - draft\nformat:\n  html:\n    code-fold: true\ndraft: true\ntoc: true\ncrossref:\n  eq-prefix: ''\n---\n\nasdklfj;aslkdjf asl djasldkj fal;skjdf ak;lsjd fklasjd flkjasdklfjlasd\nas d;kfjasdl;kf jalsdkjfalskdj f;lkasj dflaksjd flk;jasdlkfj asdlkfjasd f\nasd f;lkjasd;flkjasl;dfjk\n\n\n\n\n```{ojs}\nimport { chart } from \"d/25c985d0085db54e\"\nchart\n```\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nfrom qiskit import QuantumCircuit\nfrom qiskit.quantum_info import Statevector\nfrom math import pi\n\n\n# importing the sys module\nimport sys\n \n# the setrecursionlimit function is\n# used to modify the default recursion\n# limit set by python. Using this,\n# we can increase the recursion limit\n# to satisfy our needs\n \nsys.setrecursionlimit(10**6)\n```\n:::\n\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\ndef cpc(n):\n    qc = QuantumCircuit(n, name='   CPC')\n    for k in range(1, n):\n        qc.cp(pi/(2**k), n-1, n-1-k)\n    return qc\n\ncpc(5).draw(output='mpl', reverse_bits=True)\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n![](index_files/figure-html/cell-3-output-1.png){width=591 height=346}\n:::\n:::\n\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ndef rev(n):\n    qc = QuantumCircuit(n, name='   Rev')\n    for i in range(n//2):\n        qc.swap(i, n-i-1)\n    return qc\n\nrev(7).draw(output='mpl', reverse_bits=True)\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n![](index_files/figure-html/cell-4-output-1.png){width=288 height=468}\n:::\n:::\n\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\ndef qft(n):\n    qc = QuantumCircuit(n, name=f'  QFT')\n    qc.h(n-1)\n    if n == 1:\n        return qc\n    qc.append(cpc(n), range(n))\n    qc.append(qft(n-1), range(n-1))\n    qc.append(rev(n-1), range(n-1))\n    qc.append(rev(n), range(n))\n\n    return qc\n\nqft(5).draw(output='mpl', reverse_bits=True, style={\n    \"displaycolor\": {\n        \"   Rev\": [ # gate name\n            \"#555555\", # box color (grey)\n            \"#FFFFFF\" # box text color (white)\n        ],\n        \"  QFT\": [ # gate name\n            \"#da1e28\", # box color (red)\n            \"#FFFFFF\" # box text color (white)\n        ],\n    }})\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n![](index_files/figure-html/cell-5-output-1.png){width=652 height=346}\n:::\n:::\n\n\n::: {.cell execution_count=5}\n``` {.python .cell-code code-fold=\"false\"}\nn = 2\na = 3\nstate_in = Statevector.from_int(a, 2**n)\nstate_out = state_in.evolve(qft(n))\nstate_out.draw('latex')\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n$$\\frac{1}{2} |00\\rangle- \\frac{i}{2} |01\\rangle- \\frac{1}{2} |10\\rangle+\\frac{i}{2} |11\\rangle$$\n:::\n:::\n\n\nFor a slightly larger computation, let's compute $QFT_3|7\\rangle$:\n\n::: {.cell execution_count=6}\n``` {.python .cell-code code-fold=\"false\"}\nn = 3\na = 7\nstate_in = Statevector.from_int(a, 2**n)\nstate_out = state_in.evolve(qft(n))\nstate_out.draw('latex')\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n$$\\frac{\\sqrt{2}}{4} |000\\rangle+ (\\frac{1}{4} - \\frac{i}{4}) |001\\rangle- \\frac{\\sqrt{2} i}{4} |010\\rangle+ (- \\frac{1}{4} - \\frac{i}{4}) |011\\rangle- \\frac{\\sqrt{2}}{4} |100\\rangle+ (- \\frac{1}{4} + \\frac{i}{4}) |101\\rangle+\\frac{\\sqrt{2} i}{4} |110\\rangle+ (\\frac{1}{4} + \\frac{i}{4}) |111\\rangle$$\n:::\n:::\n\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nqft_dg = qft(3).inverse()\nqft_dg.draw(output='mpl', reverse_bits=True)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n![](index_files/figure-html/cell-8-output-1.png){width=652 height=225}\n:::\n:::\n\n\n",
    "supporting": [
      "index_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}