{
  "hash": "64775e9dd56023b0f798c4542aeb8e3b",
  "result": {
    "markdown": "---\ntitle: Quantum Phase Estimation\nauthor: Jonny Comes\ndate: '2022-12-14'\ncategories:\n  - quantum\n  - qiskit\n  - QFT\n  - phase estimation\nimage: phase_est.png\nformat:\n  html:\n    code-fold: true\ndraft: false\ntoc: true\ncrossref:\n  eq-prefix: ''\n---\n\n## Quantum phase estimation{#sec-intro}\n\nThe story of quantum phase estimation starts with a unitary matrix $U$. Suppose $|x\\rangle$ is an eigenvector of $U$ so that $U|x\\rangle=\\lambda|x\\rangle$ for some complex number $\\lambda$. Since $U$ is unitary, hence distance preserving, we know $|\\lambda|=1$ so that $\\lambda=e^{2\\pi i\\theta}$ for some $0\\leq\\theta<1$. Quantum phase estimation uses a quantum circuit, depending on $U$, to estimate $\\theta$.\n\nThe quantum circuit for quantum phase estimation depends on the quantum Fourier transform (QFT). \nIn a [previous post](../quantum-fourier-transform) I discussed QFT. In particular, I constructed a quantum circuit for QFT using [qiskit](https//:qiskit.org). In this post I will reuse that code.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nfrom qiskit import QuantumCircuit\nfrom qiskit.circuit.library.standard_gates import *\nfrom qiskit.quantum_info import Statevector\nfrom math import pi\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\ndef cpc(n):\n    '''\n    Returns an n-qubit quantum circuit consisting of a chain \n    of CP-gates to use in the construction of the QFT circuit.\n    '''\n    qc = QuantumCircuit(n, name='   CPC')\n    for k in range(1, n):\n        qc.cp(pi/(2**k), n-1, n-1-k)\n    return qc\n\ndef rev(n):\n    '''\n    Returns an n-qubit quantum circuit that reverses \n    the order of the n qubits.\n    '''\n    qc = QuantumCircuit(n, name='   Rev')\n    for i in range(n//2):\n        qc.swap(i, n-i-1)\n    return qc\n\ndef qft(n):\n    '''\n    Returns the n-qubit QFT circuit.\n    '''\n    qc = QuantumCircuit(n, name=f'  QFT')\n    qc.h(n-1)\n    if n == 1:\n        return qc\n\n    qc.append(cpc(n), range(n))\n    qc.append(qft(n-1), range(n-1))\n    qc.append(rev(n-1), range(n-1))\n    qc.append(rev(n), range(n))\n    return qc\n```\n:::\n\n\nI first read about quantum phase estimation in [qiskit's book](https://qiskit.org/textbook/ch-algorithms/quantum-phase-estimation.html) while trying to better understand Shor's algorithm. Much of what I've written below is merely a retelling of qiskit's treatment. I plan to post about Shor's algorithm soon. \n\n### Controlled $U$-gates\n\nFix a unitary matrix $U$. The controlled $U$-gate is defined by\n$$\n\\begin{align*}\nCU: & |0\\rangle\\otimes|v\\rangle \\mapsto |0\\rangle\\otimes|v\\rangle\\\\\n    & |1\\rangle\\otimes|v\\rangle \\mapsto |1\\rangle\\otimes U|v\\rangle.\n\\end{align*}\n$$\nIn particular, if $|x\\rangle$ is an eigenvector for $U$ with eigenvalue $e^{2\\pi i\\theta}$\nthen \n$$\n\\begin{align*}\nCU: & |0\\rangle\\otimes|x\\rangle \\mapsto |0\\rangle\\otimes|x\\rangle\\\\\n    & |1\\rangle\\otimes|x\\rangle \\mapsto e^{2\\pi i\\theta}|1\\rangle\\otimes|x\\rangle\n\\end{align*}\n$$\nor more compactly, for each $q\\in\\{0,1\\}$\n$$\nCU:|q\\rangle\\otimes|x\\rangle \\mapsto e^{2\\pi i\\theta q}|q\\rangle\\otimes|x\\rangle.\n$$\n\n\nMore generally, we will write $CU_k$ for the controlled $U$-gate mapping\n$$\nCU_k:|q_{n-1}\\cdots q_0\\rangle\\otimes|v\\rangle \\mapsto \n\\begin{cases}\n    |q_{n-1}\\cdots q_0\\rangle\\otimes |v\\rangle & \\text{if }q_k=0\\\\\n    |q_{n-1}\\cdots q_0\\rangle\\otimes U|v\\rangle & \\text{if }q_k=1\n\\end{cases}\n$$\nIn particular, substituting the eigenvector $|x\\rangle$ we get \n$$\nCU_k:|q_{n-1}\\cdots q_0\\rangle\\otimes|x\\rangle \\mapsto e^{2\\pi i\\theta q_k} |q_{n-1}\\cdots q_0\\rangle\\otimes|x\\rangle.\n$${#eq-CU-map}\n\n### CU-gates in qiskit\n\nWe can build a controlled $U$-gate in qiskit by applying the ``control()`` method to a gate object. For example, the following creates a CU-gate when $U=H$, the Hadamard gate, and places it in a 4-qubit circuit. \n\n::: {.cell execution_count=2}\n``` {.python .cell-code code-fold=\"false\"}\nu = HGate()\ncu = u.control()\nqc = QuantumCircuit(4)\nqc.append(cu, [2,0])\nqc.draw(output='mpl', reverse_bits=True)\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n![](index_files/figure-html/cell-3-output-1.png){width=167 height=286}\n:::\n:::\n\n\n### The quantum phase estimation circuit\nThe phase estimation circuit is given by the following composition:\n$$\n(QFT^\\dagger_n\\otimes I)(CU_{n-1}^{2^{n-1}}\\cdots CU_2^4CU_1^2CU_0)(H^{\\otimes n}\\otimes I),\n$${#eq-phase-est}\nwhere $QFT^\\dagger_n$ is the inverse quantum Fourier transform. Using the qiskit implementation of QFT from [this post](../quantum-fourier-transform), we can implement the circuit for quantum phase estimation. For example, here is the phase estimation circuit using the $Y$-gate for $U$, and $n=3$:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ndef phase_est(u, n):\n    '''\n    Returns the quantum circuit for phase estimation depending\n    on the gate u, extended with n-qubits. \n    If measure flag is True, will return with first (top)\n    measurement of first (top) n qubits.\n    '''\n    m = u.num_qubits\n    qc = QuantumCircuit(n+m)\n    \n    for i in range(n):\n        qc.h(m+i)\n    cu = u.control()\n    for i in range(n):\n        for _ in range(2**i):\n            qc.append(cu, [m+i] + list(range(m)))\n    qc.append(qft(n).inverse(), range(m, m+n))\n\n    return qc\n\n\nphase_est(YGate(), 3).draw(output='mpl', reverse_bits=True, style={\n    \"displaycolor\": {\n        \"  QFT_dg\": [ # gate name\n            \"#da1e28\", # box color (red)\n            \"#FFFFFF\" # box text color (white)\n        ],\n    }})\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n![](index_files/figure-html/cell-4-output-1.png){width=712 height=286}\n:::\n:::\n\n\n## Inputting an eigenvector to the phase estimation circuit\n\nRecall that the goal of quantum phase estimation is to find $\\theta$ where $e^{2\\pi i\\theta}$ is an eigenvalue of $U$. To see how the circuit @eq-phase-est can help to accomplish this, we input $|0\\rangle^{\\otimes n}\\otimes|x\\rangle$ where $|x\\rangle$ is an eigenvector of $U$ with eigenvalue $e^{2\\pi i\\theta}$. First we apply the Hadamard $H$ to the first (top) $n$ qubits:\n\n$$\\begin{align*}\n|0\\rangle^{\\otimes n}\\otimes|x\\rangle \n& \\mapsto \\left(\\frac{1}{\\sqrt{2}}(|0\\rangle+|1\\rangle\\right)^{\\otimes n}\\otimes|x\\rangle \\\\\n& = \\frac{1}{\\sqrt{2^n}}\\sum_{0\\leq b_0,\\ldots,b_{n-1}\\leq 1}|b_{n-1}\\cdots b_1b_0\\rangle \\otimes|x\\rangle \\\\\n\\end{align*}$${#eq-step1}\nFollowing @eq-phase-est, next we apply $CU_{n-1}^{2^{n-1}}\\cdots CU_2^4CU_1^2CU_0$. Using @eq-CU-map we see the result of applying $CU_{n-1}^{2^{n-1}}\\cdots CU_2^4CU_1^2CU_0$ to the output of @eq-step1 gives\n$$\\begin{align*}\n& \\frac{1}{\\sqrt{2^n}}\\sum_{0\\leq b_0,\\ldots,b_{n-1}\\leq 1}\\prod_{k=0}^{n-1}e^{2\\pi i\\theta b_k 2^{k}}|b_{n-1}\\cdots b_1b_0\\rangle \\otimes|x\\rangle \\\\\n= & \\frac{1}{\\sqrt{2^n}}\\sum_{0\\leq b_0,\\ldots,b_{n-1}\\leq 1}e^{2\\pi i\\theta \\sum_{k=0}^{n-1}b_k 2^{k}}|b_{n-1}\\cdots b_1b_0\\rangle \\otimes|x\\rangle \\\\\n= & \\frac{1}{\\sqrt{2^n}}\\sum_{0\\leq b<2^{n}}e^{2\\pi i\\theta b}|b\\rangle \\otimes|x\\rangle \\\\\n\\end{align*}$${#eq-step2}\nSetting $N=2^{n}$, the left state in the tensor product @eq-step2 can be rewritten as \n$$\n\\frac{1}{N}\\sum_{0\\leq b<N}e^{\\frac{2\\pi i N\\theta b}{N}}|b\\rangle.\n$${#eq-QFT-out}\nNow, since $0\\leq \\theta <1$ we have $0\\leq N\\theta<N$. If $N\\theta$ happens to be an integer, then the expression @eq-QFT-out is exactly the output $QFT_n|N\\theta\\rangle$ (see [this post](../quantum-fourier-transform)). In this case, when we compete the circuit @eq-phase-est by applying $(QFT^\\dagger_n\\otimes I)$ to @eq-step2 the result is $|N\\theta\\rangle\\otimes|x\\rangle$. Then we can measure the first (top) $n$-qubits to obtain $N\\theta$. Note that since $N=2^n$, these first $n$ qubits will give the binary representation of $\\theta$ up to a shift in the radix point. For example, if the first $n=3$ qubits are in state $|011\\rangle$, then $\\theta$ has binary representation $0.011$, so $\\theta=3/8$.  If $N\\theta$ is not an integer, the result of measuring the first $n$-qubits will give an approximation $\\theta_n$ for $\\theta$. The difference $\\theta-\\theta_n$ will approach 0 as $n\\to\\infty$, so we can improve the approximation $\\theta_n\\approx\\theta$ by picking a larger $n$. \n\n### Example: $U=Z$\n\nIn this example we let $U$ denote the standard $Z$-gate so that $U=|0\\rangle\\langle0|-|1\\rangle\\langle1|$.\nIn this case we have an eigenvector $|x\\rangle=|0\\rangle$ with eigenvalue $1$, and thus $\\theta=0$. \nLet's use the phase estimation circuit with $n=2$:\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nn = 2\npe = phase_est(ZGate(), n)\n\npe.draw(output='mpl', reverse_bits=True, style={\n    \"displaycolor\": {\n        \"  QFT_dg\": [ # gate name\n            \"#da1e28\", # box color (red)\n            \"#FFFFFF\" # box text color (white)\n        ],\n    }})\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n![](index_files/figure-html/cell-5-output-1.png){width=470 height=225}\n:::\n:::\n\n\nWe use the default input state $|00\\rangle\\otimes|x\\rangle=|000\\rangle$, which we can implement in qiskit as follows:\n\n::: {.cell execution_count=5}\n``` {.python .cell-code code-fold=\"false\"}\nin_state = Statevector.from_int(0, 2**(n+1)) \nin_state.draw('latex')\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n$$ |000\\rangle$$\n:::\n:::\n\n\nQiskit will compute the output, the result of applying the quantum phase estimation circuit to the state above, as follows:\n\n::: {.cell execution_count=6}\n``` {.python .cell-code code-fold=\"false\"}\nout_state = in_state.evolve(pe)\nout_state.draw('latex')\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n$$ |000\\rangle$$\n:::\n:::\n\n\nThe first $n=2$ qubits give $|00\\rangle=|N\\theta\\rangle$. Thus we see $\\theta = 0$, as expected.\n\nOn the other hand, $U=Z$ also has an eigenvector $|x\\rangle=|1\\rangle$ with eigenvalue $-1$ (so $\\theta=1/2$). The following code will run the state $|00\\rangle\\otimes|x\\rangle=|001\\rangle$ through the phase estimation circuit:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code code-fold=\"false\"}\nin_state = Statevector.from_int(1, 2**(n+1)) \nout_state = in_state.evolve(pe)\nout_state.draw('latex')\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n$$ |101\\rangle$$\n:::\n:::\n\n\nThis time the first $n=2$ qubits gives $|10\\rangle=|N\\theta\\rangle$, which means the binary representation of $\\theta$ is $0.10$, so $\\theta=1/2$, as expected.\n\n### Example: $U=T$\n\nIn this example we let $U$ denote the standard $T$-gate so that $U=|0\\rangle\\langle0|+e^{\\pi i/4}|1\\rangle\\langle1|$.\nLet us look at the eigenvector $|x\\rangle=|1\\rangle$ which has eigenvalue $e^{\\pi i/4}$, (so $\\theta=1/8$). \nLet's start by using the phase estimation circuit with $n=2$:\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nn = 2\npe = phase_est(TGate(), n)\n\npe.draw(output='mpl', reverse_bits=True, style={\n    \"displaycolor\": {\n        \"  QFT_dg\": [ # gate name\n            \"#da1e28\", # box color (red)\n            \"#FFFFFF\" # box text color (white)\n        ],\n    }})\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n![](index_files/figure-html/cell-9-output-1.png){width=470 height=225}\n:::\n:::\n\n\nIf we input the state $|00\\rangle\\otimes|x\\rangle=|001\\rangle$, we get the following unpleasant looking output:\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nin_state = Statevector.from_int(1, 2**(n+1)) \nout_state = in_state.evolve(pe)\nout_state.draw('latex')\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n$$(0.25 + 0.603553390593 i) |001\\rangle+ (0.25 - 0.603553390593 i) |011\\rangle+ (\\frac{1}{4} - \\frac{2^{\\frac{47}{191}} \\cdot 3^{\\frac{160}{191}} \\cdot 5^{\\frac{160}{573}} \\cdot 7^{\\frac{99}{191}} i}{21 \\pi^{\\frac{887}{573}}}) |101\\rangle+ (\\frac{1}{4} + \\frac{2^{\\frac{47}{191}} \\cdot 3^{\\frac{160}{191}} \\cdot 5^{\\frac{160}{573}} \\cdot 7^{\\frac{99}{191}} i}{21 \\pi^{\\frac{887}{573}}}) |111\\rangle$$\n:::\n:::\n\n\nIf we to measure the first $n=2$ qubits of that output, we see four states with the following probabilities:\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nprob_dict = out_state.probabilities_dict()\nstates = list(prob_dict.keys())\nfirst_states = [s[:-1] for s in states]\nprobs = [prob_dict[s] for s in states]\nsns.barplot(x=first_states, y=probs)\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n<AxesSubplot:>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-11-output-2.png){width=579 height=404}\n:::\n:::\n\n\nThe reason that we are seeing a somewhat complicated output (which you may not expect since $\\theta=1/8$ is so uncomplicated) is that we have chosen $n=2$, so that $N=2^n=4$, which gives the non-integer $N\\theta=1/2$. On the other hand, if we use a circuit with $n=3$ we get something much nicer. Here's the circuit:\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nn = 3\npe = phase_est(TGate(), n)\n\npe.draw(output='mpl', reverse_bits=True, style={\n    \"displaycolor\": {\n        \"  QFT_dg\": [ # gate name\n            \"#da1e28\", # box color (red)\n            \"#FFFFFF\" # box text color (white)\n        ],\n    }})\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n![](index_files/figure-html/cell-12-output-1.png){width=712 height=286}\n:::\n:::\n\n\nAnd here is the output when $n=3$:\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nin_state = Statevector.from_int(1, 2**(n+1)) \nout_state = in_state.evolve(pe)\nout_state.draw('latex')\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n$$ |0011\\rangle$$\n:::\n:::\n\n\nIn this case, the first 3 qubits of the output are $|001\\rangle$, so $0.001$ is the binary representation of $\\theta$, which gives $\\theta=1/8$, as expected. \n\n### Example: $U=P_{2\\pi/3}$\n\nIf the $\\theta$ we're searching for does not have a terminating binary representation, then the phase estimation circuit has no chance of outputting the exact value of $\\theta$. For example, let $U=P_{2\\pi/3}$ denote the phase gate given by $U=|0\\rangle\\langle0|+e^{2\\pi i/3}|1\\rangle\\langle1|$. Let's look at the eigenvector $|x\\rangle=|1\\rangle$ with eigenvalue $e^{2\\pi i/3}$, so that $\\theta = 1/3$. In this case, $N\\theta=N/3$ will not be an integer for any $N=2^n$, so the phase estimation circuit will only give us an approximation for $\\theta$, and we should see that approximation improving as $n$ increases. For example, if we take $n=2$, the phase estimation circuit will send $|00\\rangle\\otimes|x\\rangle=|001\\rangle$ to the following superposition:\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nu = PhaseGate(2*pi/3)\nn = 2\npe = phase_est(u, n)\nin_state = Statevector.from_int(1, 2**(n+1)) \nout_state = in_state.evolve(pe)\nout_state.draw('latex')\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n$$\\frac{1}{4} |001\\rangle+ (0.591506350946 + 0.591506350946 i) |011\\rangle- \\frac{\\sqrt{3} i}{4} |101\\rangle+ (0.158493649054 - 0.158493649054 i) |111\\rangle$$\n:::\n:::\n\n\nMeasure the first $n=2$ qubits of that output, we see all four states with the following probabilities:\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nprob_dict = out_state.probabilities_dict()\nstates = list(prob_dict.keys())\nfirst_states = [s[:-1] for s in states]\nprobs = [prob_dict[s] for s in states]\nsns.barplot(x=first_states, y=probs)\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n<AxesSubplot:>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-15-output-2.png){width=571 height=404}\n:::\n:::\n\n\nThe state with the highest probability, $|01\\rangle$, leads to the best of the four approximations, namely the one with binary representation $0.01$, i.e. $\\theta\\approx 1/4$. To get a better approximation, we take $n=3$ which leads to the following probabilities:\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nn = 3\npe = phase_est(u, n)\nin_state = Statevector.from_int(1, 2**(n+1)) \nout_state = in_state.evolve(pe)\nprob_dict = out_state.probabilities_dict()\nstates = list(prob_dict.keys())\nfirst_states = [s[:-1] for s in states]\nprobs = [prob_dict[s] for s in states]\nsns.barplot(x=first_states, y=probs)\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\n<AxesSubplot:>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-16-output-2.png){width=571 height=404}\n:::\n:::\n\n\nThe highest probability leads us to the binary representation $0.011$, which gives the approximation $\\theta\\approx 3/8$. \n\nThe following plot shows the (decimal) approximations that the phase estimation circuit produces for $2\\leq n\\leq 12$. Each point corresponds to a possible state obtained by measuring the first $n$ qubits in the output of the phase estimation circuit. The size of each point corresponds to the state's probability, and only those states with probability greater than one percent are shown. We can see that the estimates obtained are indeed approaching the true value $\\theta=1/3$. \n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\ndef scatter_phase_estimates(u, input_int=0, qubit_size=12, rare=0.01): \n    '''\n    Produces a scatter plot of the phases estimates.\n    '''\n    u_size = u.num_qubits\n    num_qbits = []\n    probs = []\n    thetas = []\n    for n in range(2, qubit_size + 1):\n        pe = phase_est(u, n)\n        in_state = Statevector.from_int(input_int, 2**(n+u_size)) \n        out_state = in_state.evolve(pe)\n        out_state.draw('latex')\n        prob_dict = out_state.probabilities_dict()\n        states = list(prob_dict.keys())\n        num_qbits += [n for s in states if prob_dict[s] > rare]\n        probs += [prob_dict[s] for s in states if prob_dict[s] > rare]\n        thetas += [int(f'{s[:-u_size]}', base=2)/2**n for s in states if prob_dict[s] > rare]\n    graph = sns.scatterplot(x=num_qbits, y=thetas, size=probs)\n    graph.set_xlabel( \"n\" , size = 12 )\n    graph.set_ylabel( \"Estimate of theta (decimal)\" , size = 12 )\n    plt.show()\n\nscatter_phase_estimates(PhaseGate(2*pi/3), input_int=1)\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-17-output-1.png){width=591 height=425}\n:::\n:::\n\n\n## Honest phase estimation: when we don't already know the eigenvalue\n\nSo far we have looked at what the phase estimation circuit does to an input of the form $|0\\rangle^{\\otimes n}\\otimes|x\\rangle$ where $|x\\rangle$ is an eigenvector of $U$. But hang on, if we know an eigenvector $|x\\rangle$ for $U$, we can just compute $U|x\\rangle$ to determine the corresponding $\\theta$. Phase estimation is only useful if it can determine (an estimate) for the phase without already knowing eigenvectors. Luckily, since $U$ is unitary it is diagonalizable (by a Spectral Theorem). In other words, $U$ admits a basis of eigenvectors. In particular, for *any* vector $|x\\rangle$ we can write \n$$\n|x\\rangle = \\alpha_1|x_1\\rangle+\\alpha_2|x_2\\rangle+\\cdots+\\alpha_m|x_m\\rangle\n$${#eq-eigensum}\nwhere $|x_1\\rangle,\\ldots,|x_m\\rangle$ are all eigenvectors of $U$. Thus, if we run $|x\\rangle$ through the phase estimation circuit will have the effect of running all the eigenvectors that appear in @eq-eigensum, weighted depending on the $\\alpha_i$'s. For example, let $U$ denote the gate corresponding to the following (essentially randomly chosen) circuit:\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\nu = QuantumCircuit(2)\nu.h(0)\nu.ch(0,1)\nu.p(pi/6, 0)\nu.cp(pi/8, 1, 0)\nu.cy(0,1)\n\nu.draw(output='mpl', reverse_bits=True)\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n![](index_files/figure-html/cell-18-output-1.png){width=470 height=165}\n:::\n:::\n\n\nSince $U$ corresponds to a $4\\times 4$ matrix, we know $U$ has at most 4 distinct eigenvalues. Let $|x\\rangle=|00\\rangle$ (which is not an eigenvector of $U$). The following shows the phase estimates obtained from the phase estimate circuit by inputting $|0\\rangle^{\\otimes n}\\otimes|x\\rangle=|0\\cdots0\\rangle$ for various values of $n$\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\nu = u.to_gate()\nscatter_phase_estimates(u)\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-19-output-1.png){width=591 height=425}\n:::\n:::\n\n\nNote that after some initial noise, the phase estimates stabilize at 4 different values. These are the four values of $\\theta$ corresponding to the 4 distinct eigenvalues of $U$. As this example illustrates, the process of quantum phase estimation really can be used to discover eigenvalues of a unitary matrix. \n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}