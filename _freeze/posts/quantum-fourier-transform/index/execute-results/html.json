{
  "hash": "2b317fae6476d25dd23f96099f7b90c8",
  "result": {
    "markdown": "---\ntitle: Quantum Fourier transform\nauthor: Jonny Comes\ndate: '2022-12-02'\ncategories:\n  - quantum\n  - qiskit\n  - QFT\nimage: qft.png\nformat:\n  html:\n    code-fold: true\ndraft: false\ntoc: true\ncrossref:\n  eq-prefix: ''\n---\n\n## The quantum Fourier transform\n\nThe Fourier transform is a beautiful function with many important applications. There is a wonderful introduction to the [Fourier transform by 3 Blue 1 Brown](https://www.youtube.com/watch?v=spUNpyF58BY) that is well worth watching. The following is a description of the quantum Fourier transform (QFT). After defining a closed formula for QFT, I will explain how to build the QFT circuit using a recursive formula. In the end, I will prove that the closed formula and recursive formula agree. All the quantum circuits in this post are created with [qiskit](https://qiskit.org). \n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nfrom qiskit import QuantumCircuit\nfrom math import pi\n```\n:::\n\n\n### $n$-qubit representations of integers\n\nFix a positive integer $n$ and let $N=2^n$ denote the dimension of the $n$-qubit state space. In what follows, given an integer $0\\leq a< N$ we write $|a\\rangle$ for the state vector corresponding to the $a$-th standard basis vector. In other words, $|a\\rangle=|a_{n-1}\\cdots a_1a_0\\rangle$ where each $a_i\\in\\{0,1\\}$ and $a=\\sum\\limits_{k=0}^{n-1}a_k2^k$. For example, when $n=3$ we have \n\n$$\\begin{align*}\n    |0\\rangle &= |000\\rangle, &\n    |1\\rangle &= |001\\rangle, \\\\\n    |2\\rangle &= |010\\rangle, &\n    |3\\rangle &= |011\\rangle, \\\\\n    |4\\rangle &= |100\\rangle, &\n    |5\\rangle &= |101\\rangle, \\\\\n    |6\\rangle &= |110\\rangle, &\n    |7\\rangle &= |111\\rangle. \\\\\n\\end{align*}$$\n\nThis is just the usual binary representation of integers, but with qubits. I like to refer to $|a\\rangle$ as the (standard) $n$-qubit representation of the integer $a$.  \n \n### A closed formula for QFT\n\nThe quantum Fourier transform $QFT_n$ is define on the $n$-qubit representation of $a$ by\n$$\nQFT_n|a\\rangle = \\dfrac{1}{\\sqrt{N}}\\sum_{b=0}^{N-1}e^{2\\pi i a b/N}|b\\rangle.\n$${#eq-closed-QFT}\n\n#### Example: $QFT_1$\n\nWhen $n=1$ (so that $N=2$) the closed formula above shows that $QFT_1$ maps\n\n$$\\begin{align*}\n    |0\\rangle & \\mapsto \\dfrac{1}{\\sqrt{2}}\\left(|0\\rangle + |1\\rangle\\right)\\\\\n    |1\\rangle & \\mapsto \\dfrac{1}{\\sqrt{2}}\\left(|0\\rangle - |1\\rangle\\right)\n\\end{align*}$$\n\nThis is the same mapping given by our beloved Hadamard gate, so $QFT_1=H$.\n\n#### Example: $QFT_2$\n\nWhen $n=2$ (so that $N=4$) the closed formula shows that $QFT_2$ maps\n\n$$\\begin{align*}\n    |0\\rangle & \\mapsto \\dfrac{1}{2}\\left(|0\\rangle + |1\\rangle + |2\\rangle + |3\\rangle\\right)\\\\\n    |1\\rangle & \\mapsto \\dfrac{1}{2}\\left(|0\\rangle + i|1\\rangle -|2\\rangle - i|3\\rangle\\right)\\\\\n    |2\\rangle & \\mapsto \\dfrac{1}{2}\\left(|0\\rangle - |1\\rangle + |2\\rangle - |3\\rangle\\right)\\\\\n    |3\\rangle & \\mapsto \\dfrac{1}{2}\\left(|0\\rangle - i|1\\rangle - |2\\rangle + i|3\\rangle\\right)\n\\end{align*}$${#eq-QFT-int-examples}\n\nEquivalently, expanding the above states into qubits we see $QFT_2$ maps\n\n$$\\begin{align*}\n    |00\\rangle & \\mapsto \\dfrac{1}{2}\\left(|00\\rangle + |01\\rangle + |10\\rangle + |11\\rangle\\right)\\\\\n    |01\\rangle & \\mapsto \\dfrac{1}{2}\\left(|00\\rangle + i|01\\rangle -|10\\rangle - i|11\\rangle\\right)\\\\\n    |10\\rangle & \\mapsto \\dfrac{1}{2}\\left(|00\\rangle - |01\\rangle + |10\\rangle - |11\\rangle\\right)\\\\\n    |11\\rangle & \\mapsto \\dfrac{1}{2}\\left(|00\\rangle - i|01\\rangle - |10\\rangle + i|11\\rangle\\right)\n\\end{align*}$${#eq-QFT-qubit-examples}\n\n## The QFT circuit\n\n### CP-chains\n\nOne of the building blocks (subcircuits) of the QFT circuit consists of a composition of controlled phase gates. We will call these subcircuits CP-chains. In the following we will describe these CP-chains and give an explicit formula for how they map qubit states. \n\n#### Phase gates\n\nWe will write $P_\\phi$ for the P-gate, which depends on a parameter $\\phi$, that maps qubits as follows \n\n$$\\begin{align*}\n    |0\\rangle & \\mapsto |0\\rangle\\\\\n    |1\\rangle & \\mapsto e^{\\phi i} |1\\rangle\n\\end{align*}$$\nIn other words, a P-gate applies a relative phase change to the $|1\\rangle$ component of a qubit. \nIf you prefer to describe gates by matrices, then \n$$P_\\phi=\\begin{pmatrix}\n    1 & 0\\\\\n    0 & e^{\\phi i}\n\\end{pmatrix}$$\n\nNote that we can get a little clever and write the P-gate mapping as\n$$P_\\phi: |q\\rangle \\mapsto e^{q\\phi i}|q\\rangle$$\nwhere $q\\in\\{0, 1\\}$. The P-gate $P_{\\pi/2}$ is pictured as follows:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nqc = QuantumCircuit(1)\nqc.p(pi/2, 0)\nqc.draw(output='mpl')\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n![](index_files/figure-html/cell-3-output-1.png){width=154 height=104}\n:::\n:::\n\n\n#### Controlled phase gates\n\nUsing the cleverness above, a controlled P-gate will map\n$$CP_\\phi: |q_1q_0\\rangle \\mapsto e^{q_1q_0\\phi i}|q_1q_0\\rangle.$$\n\n\nThe controlled P-gate $CP_{\\pi/2}$ is drawn as follows:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nqc = QuantumCircuit(2)\nqc.cp(pi/2, 0, 1)\nqc.draw(output='mpl', reverse_bits=True)\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n![](index_files/figure-html/cell-4-output-1.png){width=227 height=165}\n:::\n:::\n\n\n#### A chain of controlled phase gates {#sec-CPC}\n\nSuppose we are concerned with a $(n+1)$-qubit state space. Consider $n$ CP-gates: $CP_{\\pi/2^k}$ between the $n$-th and $(n-k)$-th qubit for each $1\\leq k\\leq n$. For example, when $n=4$ the composition of these four CP-gates is the following:\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\ndef cpc(n):\n    qc = QuantumCircuit(n, name='   CPC   ')\n    for k in range(1, n):\n        qc.cp(pi/(2**k), n-1, n-1-k)\n    return qc\n\ncpc(5).draw(output='mpl', reverse_bits=True)\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n![](index_files/figure-html/cell-5-output-1.png){width=591 height=346}\n:::\n:::\n\n\nI don't know a standard name for the circuit above, so I'll refer to the composition of these $n$ CP-gates as the CP-chain, denoted $CPC_{n+1}$. For example, the circuit drawn above is $CPC_5$. Based on the mapping of $CP_\\phi$ given above, it follows that the CP-chain maps $|a\\rangle=|a_n\\cdots a_1a_0\\rangle$, the $(n+1)$-qubit representation of an integer $0\\leq a< 2^{n+1}$, as follows:\n$$CPC_{n+1}:|a_na_{n-1}\\cdots a_1a_0\\rangle \\mapsto \\prod\\limits_{k=1}^ne^{\\frac{\\pi i \na_na_{n-k}}{2^k}}|a_na_{n-1}\\cdots a_1a_0\\rangle$$\nTo simplify the expression above, it will be useful to let $a'$ denote the integer with $n$-qubit representation $|a'\\rangle=|a_{n-1}\\cdots a_1a_0\\rangle$ so that $|a\\rangle=|a_n\\rangle\\otimes|a'\\rangle$.\nWith this notation, the amplitude above simplifies as\n$$\\begin{align*}\n    \\prod\\limits_{k=1}^ne^{\\frac{\\pi i a_na_{n-k}}{2^k}}\n    & =e^{\\sum_{k=1}^n\\frac{\\pi i a_na_{n-k}}{2^k}} \\\\\n    & =e^{\\frac{\\pi i a_n}{2^n}\\sum_{k=1}^na_{n-k}2^{n-k}} \\\\ \n    & =e^{\\frac{\\pi i a_n}{2^n}\\sum_{k=0}^{n-1}a_{k}2^{k}} \\\\\n    & =e^{\\frac{\\pi i a_na'}{2^n}}. \\\\\n\\end{align*}$$\nThus, the CP-chain mapping can be written as\n$$\nCPC_{n+1}:|a_n\\rangle\\otimes|a'\\rangle \\mapsto e^{\\frac{\\pi i a_na'}{2^n}} |a_n\\rangle\\otimes|a'\\rangle.\n$${#eq-CPC}\n\n\n\n\n### Reverse circuits\n\nReversing the order of the qubits is another component of the QFT circuit. Reversing qubits can easily be accomplished using swap gates. The swap gate, pictured below, maps $|q_1q_0\\rangle\\to|q_0q_1\\rangle$.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nqc = QuantumCircuit(2)\nqc.swap(0, 1)\nqc.draw(output='mpl', reverse_bits=True)\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n![](index_files/figure-html/cell-6-output-1.png){width=167 height=165}\n:::\n:::\n\n\nWe let $Rev_n$ for the $n$-qubit gate that reverses the qubit order. For example, $Rev_2$ is the swap gate above. To obtain $Rev_n$, one simply swaps the first and last qubit, the second and second to last qubit, and so on. For example, the following is $Rev_7$:\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\ndef rev(n):\n    qc = QuantumCircuit(n, name='   Rev   ')\n    for i in range(n//2):\n        qc.swap(i, n-i-1)\n    return qc\n\nrev(7).draw(output='mpl', reverse_bits=True)\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n![](index_files/figure-html/cell-7-output-1.png){width=288 height=468}\n:::\n:::\n\n\n### A recursive formula for QFT\n\nWe are now in position to state recursive formula for the QFT that will allow use to build the QFT circuits:\n\n$$\nQFT_{n+1} = Rev_{n+1}\\circ (I\\otimes (Rev_n\\circ QFT_n))\\circ CPC_{n+1}\\circ(H\\otimes I^{\\otimes n})\n$$ {#eq-rec-QFT}\n\nThe formula above may be easier to visualize using circuits. Here is the recursively defined QFT circuit:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\ndef qft(n):\n    qc = QuantumCircuit(n, name=f'  QFT  ')\n    qc.h(n-1)\n    if n == 1:\n        return qc\n    qc.append(cpc(n), range(n))\n    qc.append(qft(n-1), range(n-1))\n    qc.append(rev(n-1), range(n-1))\n    qc.append(rev(n), range(n))\n\n    return qc\n\nqft(5).draw(output='mpl', reverse_bits=True, style={\n    \"displaycolor\": {\n        \"   Rev   \": [ # gate name\n            \"#555555\", # box color (grey)\n            \"#FFFFFF\" # box text color (white)\n        ],\n        \"  QFT  \": [ # gate name\n            \"#da1e28\", # box color (red)\n            \"#FFFFFF\" # box text color (white)\n        ],\n    }})\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n![](index_files/figure-html/cell-8-output-1.png){width=652 height=346}\n:::\n:::\n\n\n### The QFT circuit\n\nStarting with $QFT_1=H$, the recursive formula @eq-rec-QFT can be used to build all the QFT circuits in terms of H, CP, and swap gates. For example, here is $QFT_2$:\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nqc = QuantumCircuit(2)\nqc.h(1)\nqc.cp(pi/2, 1, 0)\nqc.h(0)\nqc.swap(0,1)\nqc.draw(output='mpl', reverse_bits=True)\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n![](index_files/figure-html/cell-9-output-1.png){width=409 height=165}\n:::\n:::\n\n\nPlugging this into the recursive formula @eq-rec-QFT gives us $QFT_3$. After simplifying (Rev-gates are their own inverses) and expanding the CPC and Rev gates into CP and swap gates, we get the following for $QFT_3$:\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nqc = QuantumCircuit(3)\nqc.h(2)\nqc.cp(pi/2, 2, 1)\nqc.cp(pi/4, 2, 0)\nqc.h(1)\nqc.cp(pi/2, 1, 0)\nqc.h(0)\nqc.swap(0,2)\nqc.draw(output='mpl', reverse_bits=True)\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n![](index_files/figure-html/cell-10-output-1.png){width=712 height=225}\n:::\n:::\n\n\nSimilarly, we can plug the QFT-circuit above into the recursive formula @eq-rec-QFT and (after expanding and simplifying) get $QFT_4$ in terms of H, CP, and swap gates:\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nqc = QuantumCircuit(4)\nqc.h(3)\nqc.cp(pi/2, 3, 2)\nqc.cp(pi/4, 3, 1)\nqc.cp(pi/8, 3, 0)\nqc.h(2)\nqc.cp(pi/2, 2, 1)\nqc.cp(pi/4, 2, 0)\nqc.h(1)\nqc.cp(pi/2, 1, 0)\nqc.h(0)\nqc.swap(0,3)\nqc.swap(1,2)\nqc.draw(output='mpl', reverse_bits=True)\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n![](index_files/figure-html/cell-11-output-1.png){width=1137 height=286}\n:::\n:::\n\n\n### A couple QFT computations with qiskit\n\nIn the code blocks above, the recursive formula @eq-rec-QFT was used to create the QFT-circuit with qiskit. \nThe following shows how to perform QFT calculations with qiskit. First, lets check that our circuit correctly computes $QFT_2|3\\rangle$ (compare with @eq-QFT-int-examples and @eq-QFT-qubit-examples).\n\n::: {.cell execution_count=11}\n``` {.python .cell-code code-fold=\"false\"}\nfrom qiskit.quantum_info import Statevector\nn = 2\na = 3\nstate_in = Statevector.from_int(a, 2**n)\nstate_out = state_in.evolve(qft(n))\nstate_out.draw('latex')\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n$$\\frac{1}{2} |00\\rangle- \\frac{i}{2} |01\\rangle- \\frac{1}{2} |10\\rangle+\\frac{i}{2} |11\\rangle$$\n:::\n:::\n\n\nFor a slightly larger computation, let's compute $QFT_3|7\\rangle$:\n\n::: {.cell execution_count=12}\n``` {.python .cell-code code-fold=\"false\"}\nn = 3\na = 7\nstate_in = Statevector.from_int(a, 2**n)\nstate_out = state_in.evolve(qft(n))\nstate_out.draw('latex')\n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n$$\\frac{\\sqrt{2}}{4} |000\\rangle+ (\\frac{1}{4} - \\frac{i}{4}) |001\\rangle- \\frac{\\sqrt{2} i}{4} |010\\rangle+ (- \\frac{1}{4} - \\frac{i}{4}) |011\\rangle- \\frac{\\sqrt{2}}{4} |100\\rangle+ (- \\frac{1}{4} + \\frac{i}{4}) |101\\rangle+\\frac{\\sqrt{2} i}{4} |110\\rangle+ (\\frac{1}{4} + \\frac{i}{4}) |111\\rangle$$\n:::\n:::\n\n\n## Proof that QFT satisfies the recursive formula\n\nTo prove the recursive formula @eq-rec-QFT we compute the output of the recursive circuit on \nan arbitrary $(n+1)$-qubit representation of an integer: $|a\\rangle=|a_na_{n-1}\\cdots a_0\\rangle$. \nIn doing so, it will continue to use the notation from @sec-CPC by writing\n$$\n|a\\rangle=|a_n\\rangle\\otimes|a'\\rangle.\n$${#eq-aap}\nFollowing @eq-rec-QFT, we first apply the Hadamard gate (which is $QFT_1$) to the left (top) qubit:\n$$\n|a_n\\rangle\\otimes|a'\\rangle \\mapsto \\dfrac{1}{\\sqrt{2}}\\sum_{0\\leq b_0\\leq 1}e^{\\pi i a_n b_0}|b_0\\rangle\\otimes|a'\\rangle.\n$$\nNext, (according to @eq-rec-QFT) we apply the CPC-gate to the result and use @eq-CPC to get\n$$\n\\dfrac{1}{\\sqrt{2}}\\sum_{0\\leq b_0\\leq 1}e^{\\pi i b_0 a_n}|b_0\\rangle\\otimes|a'\\rangle\\mapsto \\dfrac{1}{\\sqrt{2}}\\sum_{0\\leq b_0\\leq 1}e^{\\pi i b_0 a_n}e^{\\frac{\\pi i b_0 a'}{2^n}}|b_0\\rangle\\otimes|a'\\rangle.\n$${#eq-afterCPC}\nSince \n$$\n2^na_n + a'=a\n$${#eq-axpand} \n(which follows from @eq-aap), the exponentials in the output of @eq-afterCPC can be simplified as follows:\n$$\ne^{\\pi i b_0 a_n}e^{\\frac{\\pi i b_0 a'}{2^n}}=e^{\\frac{\\pi i b_0(2^na_n+a')}{2^n}}=e^{\\frac{\\pi i b_0 a}{2^n}}\n$$\nThus, the output of @eq-afterCPC can be written as\n$$\n\\dfrac{1}{\\sqrt{2}}\\sum_{0\\leq b_0\\leq 1}e^{\\frac{\\pi i b_0 a}{2^n}}|b_0\\rangle\\otimes|a'\\rangle.\n$$\nNext, (according to @eq-rec-QFT) we apply the QFT-gate to the right (bottom) $n$ qubits using @eq-closed-QFT:\n$$\n\\dfrac{1}{\\sqrt{2}}\\sum_{0\\leq b_0\\leq 1}e^{\\frac{\\pi i b_0 a}{2^n}}|b_0\\rangle\\otimes|a'\\rangle\n\\mapsto\n\\dfrac{1}{\\sqrt{2}}\\sum_{0\\leq b_0\\leq 1}e^{\\frac{\\pi i b_0 a}{2^n}}|b_0\\rangle\\otimes\\dfrac{1}{\\sqrt{2^n}}\\sum_{0\\leq b'<2^n}e^{\\frac{2\\pi i a'b'}{2^n}}|b'\\rangle.\n$$\nIf we write $|b'\\rangle=|b_nb_{n-1}\\cdots b_1\\rangle$, then the output above can be written as\n$$\n\\dfrac{1}{\\sqrt{2^{n+1}}}\\sum_{0\\leq b_0,b_1,\\ldots,b_n\\leq 1}e^{\\frac{\\pi i b_0 a}{2^n}}e^{\\frac{2\\pi i a'b'}{2^n}}|b_0\\rangle\\otimes|b_n\\cdots b_1\\rangle.\n$$\nNow, (still following @eq-rec-QFT) we reverse the last (bottom) $n$ qubits to get \n\n$$\\begin{align*}\n& \\dfrac{1}{\\sqrt{2^{n+1}}}\\sum_{0\\leq b_0,b_1,\\ldots,b_n\\leq 1}e^{\\frac{\\pi i b_0 a}{2^n}}e^{\\frac{2\\pi i a'b'}{2^n}}|b_0\\rangle\\otimes|b_1\\cdots b_n\\rangle \\\\\n& =\\dfrac{1}{\\sqrt{2^{n+1}}}\\sum_{0\\leq b_0,b_1,\\ldots,b_n\\leq 1}e^{\\frac{\\pi i b_0 a}{2^n}}e^{\\frac{2\\pi i a'b'}{2^n}}|b_0b_1\\cdots b_n\\rangle. \\\\\n& =\\dfrac{1}{\\sqrt{2^{n+1}}}\\sum_{0\\leq b_0,b_1,\\ldots,b_n\\leq 1}e^{\\frac{\\pi i (ab_0+2a'b')}{2^n}}|b_0b_1\\cdots b_n\\rangle.\n\\end{align*}$${#eq-after-small-reverse}\n\nFinally, if we let $b$ denote the integer with $|b\\rangle=|b_n\\cdots b_0\\rangle$, then after we reverse all $n+1$ qubits (the last step in @eq-rec-QFT) in @eq-after-small-reverse we get\n$$\n\\dfrac{1}{\\sqrt{2^{n+1}}}\\sum_{0\\leq b_0,\\ldots,b_n\\leq 1}e^{\\frac{\\pi i (ab_0+2a'b')}{2^n}}|b_n\\cdots b_0\\rangle\n=\n\\dfrac{1}{\\sqrt{2^{n+1}}}\\sum_{b=0}^{2^{n+1}-1}e^{\\frac{\\pi i (ab_0+2a'b')}{2^n}}|b\\rangle.\n$$\nThe state above the output of the recursive gate @eq-rec-QFT applied to $|a\\rangle$. On the other hand, using @eq-closed-QFT we get \n$$\nQFT_{n+1}|a\\rangle = \\dfrac{1}{\\sqrt{2^{n+1}}}\\sum_{b=0}^{2^{n+1}-1}e^{\\frac{2\\pi i ab}{2^{n+1}}}|b\\rangle.\n$$\nThus, to complete the proof it suffices to show \n$$\ne^{\\frac{\\pi i (ab_0+2a'b')}{2^n}} = e^{\\frac{2\\pi i ab}{2^{n+1}}}\n$$\nor equivalently\n$$\ne^{\\frac{\\pi i (ab-ab_0-2a'b')}{2^{n}}} = 1.\n$$\n\nSince $|b\\rangle=|b_n\\cdots b_1b_0\\rangle$ and $|b'\\rangle=|b_n\\cdots b_1\\rangle$, it follows that $b=2b'+b_0$ so that $b-b_0=2b'$. Using this fact along with $a-a'=2^na_n$ (which follows from @eq-axpand) we get the desired result:\n$$\\begin{align*}\ne^{\\frac{\\pi i (ab-ab_0-2a'b')}{2^{n}}}\n& = e^{\\frac{\\pi i (2ab'-2a'b')}{2^{n}}} \\\\\n& = e^{\\frac{\\pi i (2(a-a')b')}{2^{n}}} \\\\\n& = e^{\\frac{\\pi i (2^{n+1}a_nb')}{2^{n}}}\\\\\n& = e^{2\\pi i a_nb'}\\\\\n& = 1.\n\\end{align*}$$\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}