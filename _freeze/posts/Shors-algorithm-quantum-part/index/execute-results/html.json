{
  "hash": "966dce854ed4ebd64899baf3961aa244",
  "result": {
    "markdown": "---\ntitle: Shor's Algorithm\nauthor: Jonny Comes\ndate: '2022-12-16'\ncategories:\n  - quantum\n  - qiskit\n  - QFT\n  - phase estimation\n  - Shor's Algorithm\nimage: phase_est.png\nformat:\n  html:\n    code-fold: true\ndraft: true\ntoc: true\ncrossref:\n  eq-prefix: ''\n---\n\n## Shor's Algorithm{#sec-intro}\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nfrom qiskit import QuantumCircuit\nfrom qiskit.quantum_info.operators import Operator\nfrom qiskit.quantum_info import Statevector\nfrom math import pi\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport math\n\ndef cpc(n):\n    '''\n    Returns an n-qubit quantum circuit consisting of a chain \n    of CP-gates to use in the construction of the QFT circuit.\n    '''\n    qc = QuantumCircuit(n, name='   CPC')\n    for k in range(1, n):\n        qc.cp(pi/(2**k), n-1, n-1-k)\n    return qc\n\ndef rev(n):\n    '''\n    Returns an n-qubit quantum circuit that reverses \n    the order of the n qubits.\n    '''\n    qc = QuantumCircuit(n, name='   Rev')\n    for i in range(n//2):\n        qc.swap(i, n-i-1)\n    return qc\n\ndef qft(n):\n    '''\n    Returns the n-qubit QFT circuit.\n    '''\n    qc = QuantumCircuit(n, name=f'  QFT')\n    qc.h(n-1)\n    if n == 1:\n        return qc\n\n    qc.append(cpc(n), range(n))\n    qc.append(qft(n-1), range(n-1))\n    qc.append(rev(n-1), range(n-1))\n    qc.append(rev(n), range(n))\n    return qc\n\ndef phase_est(u, n):\n    '''\n    Returns the quantum circuit for phase estimation depending\n    on the gate u, extended with n-qubits. \n    If measure flag is True, will return with first (top)\n    measurement of first (top) n qubits.\n    '''\n    m = u.num_qubits\n    qc = QuantumCircuit(n+m)\n    \n    for i in range(n):\n        qc.h(m+i)\n    cu = u.control()\n    for i in range(n):\n        for _ in range(2**i):\n            qc.append(cu, [m+i] + list(range(m)))\n    qc.append(qft(n).inverse(), range(m, m+n))\n\n    return qc\n\ndef scatter_phase_estimates(u, input_int=0, qubit_size=12, rare=0.01): \n    '''\n    Produces a scatter plot of the phases estimates.\n    '''\n    u_size = u.num_qubits\n    num_qbits = []\n    probs = []\n    thetas = []\n    for n in range(2, qubit_size + 1):\n        pe = phase_est(u, n)\n        in_state = Statevector.from_int(input_int, 2**(n+u_size)) \n        out_state = in_state.evolve(pe)\n        out_state.draw('latex')\n        prob_dict = out_state.probabilities_dict()\n        states = list(prob_dict.keys())\n        num_qbits += [n for s in states if prob_dict[s] > rare]\n        probs += [prob_dict[s] for s in states if prob_dict[s] > rare]\n        thetas += [int(f'{s[:-u_size]}', base=2)/2**n for s in states if prob_dict[s] > rare]\n    graph = sns.scatterplot(x=num_qbits, y=thetas, size=probs)\n    graph.set_xlabel( \"n\" , size = 12 )\n    graph.set_ylabel( \"Estimate of theta (decimal)\" , size = 12 )\n    plt.show()\n```\n:::\n\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\ndef u_matrix(a, N):\n    n = math.ceil(math.log(N, 2))\n    row = [0 for _ in range(2**n)]\n    mtx = [row[:] for _ in range(2**n)]\n    for j in range(N):\n        i = a*j % N\n        mtx[i][j] = 1\n    for i in range(N, 2**n):\n        mtx[i][i] = 1\n    return mtx\n\ndef u_gate(a, N):\n    n = math.ceil(math.log(N, 2))\n    circuit = QuantumCircuit(n)\n    u = Operator(u_matrix(a,N))\n    circuit.unitary(u, range(n), label='U')\n    return circuit.to_gate(label='U')\n```\n:::\n\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nN = 35\na = 3\nn = 4\nu = u_gate(a, N)\npe = phase_est(u, n)\nin_state = Statevector.from_int(1, 2**(n + math.ceil(math.log(N, 2))))\nout_state = in_state.evolve(pe)\nout_state.draw('latex')\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n$$\\frac{1}{8} |0000000001\\rangle+\\frac{1}{8} |0000000011\\rangle+\\frac{1}{16} |0000000100\\rangle+\\frac{1}{8} |0000001001\\rangle+\\frac{1}{16} |0000001011\\rangle+\\frac{1}{16} |0000001100\\rangle + \\ldots - \\frac{1}{16} |1111010000\\rangle+ (-0.057742470782 + 0.023917714523 i) |1111010001\\rangle+ (0.081660185305 + 0.033824756259 i) |1111011011\\rangle+ (- \\frac{125 \\cdot 2^{\\frac{101}{118}} \\cdot 3^{\\frac{31}{118}} \\cdot 5^{\\frac{13}{59}} \\cdot 7^{\\frac{45}{59}}}{5184 \\pi^{\\frac{109}{59}}} + \\frac{125 \\cdot 2^{\\frac{101}{118}} \\cdot 3^{\\frac{31}{118}} \\cdot 5^{\\frac{13}{59}} \\cdot 7^{\\frac{45}{59}} i}{5184 \\pi^{\\frac{109}{59}}}) |1111011101\\rangle+ (-0.023917714523 + 0.057742470782 i) |1111100001\\rangle$$\n:::\n:::\n\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nscatter_phase_estimates(u, input_int=1, qubit_size=6, rare=0.01)\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-5-output-1.png){width=591 height=425}\n:::\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}