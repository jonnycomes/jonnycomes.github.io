{
  "hash": "b54e0bf4f90873ccc3c74e503a0f545b",
  "result": {
    "markdown": "---\ntitle: Shor's Algorithm\nauthor: Jonny Comes\ndate: '2022-12-16'\ncategories:\n  - quantum\n  - qiskit\n  - QFT\n  - phase estimation\n  - Shor's Algorithm\nimage: phase_est.png\nformat:\n  html:\n    code-fold: true\ndraft: true\ntoc: true\ncrossref:\n  eq-prefix: ''\n---\n\n## Shor's Algorithm{#sec-intro}\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nfrom qiskit import QuantumCircuit\nfrom qiskit.quantum_info.operators import Operator\nfrom qiskit.quantum_info import Statevector\nfrom math import pi\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport math\n\ndef cpc(n):\n    '''\n    Returns an n-qubit quantum circuit consisting of a chain \n    of CP-gates to use in the construction of the QFT circuit.\n    '''\n    qc = QuantumCircuit(n, name='   CPC')\n    for k in range(1, n):\n        qc.cp(pi/(2**k), n-1, n-1-k)\n    return qc\n\ndef rev(n):\n    '''\n    Returns an n-qubit quantum circuit that reverses \n    the order of the n qubits.\n    '''\n    qc = QuantumCircuit(n, name='   Rev')\n    for i in range(n//2):\n        qc.swap(i, n-i-1)\n    return qc\n\ndef qft(n):\n    '''\n    Returns the n-qubit QFT circuit.\n    '''\n    qc = QuantumCircuit(n, name=f'  QFT')\n    qc.h(n-1)\n    if n == 1:\n        return qc\n\n    qc.append(cpc(n), range(n))\n    qc.append(qft(n-1), range(n-1))\n    qc.append(rev(n-1), range(n-1))\n    qc.append(rev(n), range(n))\n    return qc\n\ndef phase_est(u, n):\n    '''\n    Returns the quantum circuit for phase estimation depending\n    on the gate u, extended with n-qubits. \n    If measure flag is True, will return with first (top)\n    measurement of first (top) n qubits.\n    '''\n    m = u.num_qubits\n    qc = QuantumCircuit(n+m)\n    \n    for i in range(n):\n        qc.h(m+i)\n    cu = u.control()\n    for i in range(n):\n        for _ in range(2**i):\n            qc.append(cu, [m+i] + list(range(m)))\n    qc.append(qft(n).inverse(), range(m, m+n))\n\n    return qc\n\ndef scatter_phase_estimates(u, input_int=0, qubit_size=12, rare=0.01): \n    '''\n    Produces a scatter plot of the phases estimates.\n    '''\n    u_size = u.num_qubits\n    num_qbits = []\n    probs = []\n    thetas = []\n    for n in range(2, qubit_size + 1):\n        pe = phase_est(u, n)\n        in_state = Statevector.from_int(input_int, 2**(n+u_size)) \n        out_state = in_state.evolve(pe)\n        out_state.draw('latex')\n        prob_dict = out_state.probabilities_dict()\n        states = list(prob_dict.keys())\n        num_qbits += [n for s in states if prob_dict[s] > rare]\n        probs += [prob_dict[s] for s in states if prob_dict[s] > rare]\n        thetas += [int(f'{s[:-u_size]}', base=2)/2**n for s in states if prob_dict[s] > rare]\n    graph = sns.scatterplot(x=num_qbits, y=thetas, size=probs)\n    graph.set_xlabel( \"n\" , size = 12 )\n    graph.set_ylabel( \"Estimate of theta (decimal)\" , size = 12 )\n    plt.show()\n```\n:::\n\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\ndef u_matrix(a, N):\n    n = math.ceil(math.log(N, 2))\n    row = [0 for _ in range(2**n)]\n    mtx = [row[:] for _ in range(2**n)]\n    for j in range(N):\n        i = a*j % N\n        mtx[i][j] = 1\n    for i in range(N, 2**n):\n        mtx[i][i] = 1\n    return mtx\n\ndef u_gate(a, N):\n    n = math.ceil(math.log(N, 2))\n    circuit = QuantumCircuit(n)\n    u = Operator(u_matrix(a,N))\n    circuit.unitary(u, range(n), label='U')\n    return circuit.to_gate(label='U')\n```\n:::\n\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nN = 35\na = 3\nm = 6 #math.ceil(math.log(N, 2)) #number of qubits for phase est.\nn = math.ceil(math.log(N, 2)) #min num of qubits with states |0>,...,|N-1>\nu = u_gate(a, N)\npe = phase_est(u, m)\nin_state = Statevector.from_int(1, 2**(m + n))\nout_state = in_state.evolve(pe)\nstate_probs = out_state.probabilities_dict()\nstates = list(state_probs.keys())\nfirst_states = [int(s[:m], base=2) for s in states]\nfirst_states = list(set(first_states))\nprobs = []\nfor s in first_states:\n    probs.append(0)\n    for state in states:\n        if int(state[:m], base=2) == s:\n            probs[-1] += state_probs[state]\n#probs = [state_probs[s] for s in states]\nprint(first_states)\nprint(probs)\nsns.barplot(x=first_states, y=probs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63]\n[0.08398437499997916, 0.0007041789332282556, 0.0009071603399749561, 0.0014932290918517968, 0.0039062499999997563, 0.0573781295482374, 0.014717839660025038, 0.0029244624266718793, 0.0019531249999997055, 0.002924462426671413, 0.014717839660020408, 0.057378129548245636, 0.0039062499999993647, 0.0014932290918516938, 0.000907160339974948, 0.0007041789332283115, 0.083984374999989, 0.000704178933228306, 0.0009071603399749545, 0.0014932290918516864, 0.0039062499999993026, 0.05737812954823344, 0.014717839660022882, 0.002924462426671484, 0.0019531249999995234, 0.002924462426671133, 0.014717839660018541, 0.05737812954823857, 0.0039062499999988737, 0.0014932290918515407, 0.0009071603399748698, 0.0007041789332282775, 0.08398437499999148, 0.0007041789332283206, 0.0009071603399749909, 0.001493229091851806, 0.0039062499999997285, 0.05737812954823106, 0.014717839660027062, 0.0029244624266718377, 0.001953124999999251, 0.002924462426669869, 0.01471783966000697, 0.05737812954825698, 0.003906249999998086, 0.0014932290918512143, 0.0009071603399746918, 0.0007041789332281718, 0.08398437499998049, 0.0007041789332282879, 0.000907160339974993, 0.0014932290918518703, 0.0039062499999998404, 0.057378129548228476, 0.014717839660029975, 0.0029244624266719444, 0.001953124999999043, 0.0029244624266689732, 0.014717839659998733, 0.05737812954827324, 0.003906249999997509, 0.0014932290918509784, 0.0009071603399745711, 0.0007041789332281068]\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\n<AxesSubplot:>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-4-output-3.png){width=584 height=404}\n:::\n:::\n\n\n### Phase Estimation\n\nHello!\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}